;; -*- mode: clojure;-*-

(ns torque.compiler
  (:require
    [torque.analyzer :as a]
    [torque.analyzer.env :as env]
    [torque.analyzer.torque :as trq]
    [torque.analyzer.resolver :as r]
    [torque.compiler.jit  :as jit]
    [torque.compiler.emit :as emit]
    [torque.io.fs :as fs]))

(def ^:dynamic *compiler-env*
  "The global environment of the compiler. This holds all name
  sapce compiled so far"
  (atom (a/empty-env)))

(def arities-table
  (emit/define-struct "Method" [(emit/array-type emit/int8-ptr 8)]))

(def dispatch-entry
  (emit/define-struct "DispatchEntry"
    [emit/int32 (emit/ptr-of arities-table)]))

(def dispatch-table (emit/ptr-of dispatch-entry))

(def Type   (emit/define-struct "TrqType" [emit/int32 dispatch-table]))
(def TypeP  (emit/ptr-of Type))
(def Value  (emit/define-struct "TrqValue" [(emit/ptr-of Type)]))
(def ValueP (emit/ptr-of Value))

(defn fun-context [fun builder]
  {:fun fun :builder builder :env {:locals {}}})

(defmulti -compile-ast (fn [ast ctx] (:op ast)))

(def ^:dynamic compile-ast
  -compile-ast)

(defn compile-all [coll ctx]
  (mapv
    (fn [x]
      (-compile-ast x ctx))
    coll))

(defmethod -compile-ast :default [ast ctx])

(defmethod -compile-ast :const [ast ctx]
  {:value
   (cond
     (= (:type ast) :nil)    emit/nil*
     (= (:type ast) :bool)   (emit/bool (:val ast))
     (= (:type ast) :number) (emit/int (:val ast)))})

(defmethod -compile-ast :local [ast ctx]
  {:value (-> ctx :env :locals (get (:name ast)))})

(defmethod -compile-ast :do [ast ctx]
  (loop [stmts (seq (:statements ast))]
    (when-let [stmt (first stmts)]
      (-compile-ast stmt ctx)
      (recur (next stmts))))
  (-compile-ast (:ret ast) ctx))

(defn ^:private emit-bindings [ast ctx]
  (reduce
   (fn [ctx binding]
     (let [value (-compile-ast (:init binding) ctx)]
       (assoc-in ctx [:env :locals (:name binding)] value)))
    ctx
    (:bindings ast)))

(defmethod -compile-ast :let [ast ctx]
  (-compile-ast (:body ast) (emit-bindings ast ctx)))

(defn ^:private emit-loop-storage [ast ctx]
  (mapv
   (fn [binding]
      (let [init  (-compile-ast (:init binding) ctx)
            label (name (:name binding))]
        (emit/mutable-local (:builder ctx) (:value init) label)))
    (:bindings ast)))

(defn ^:private load-loop-bindings [builder bindings mutables]
  (->> (map (fn [binding mutable]
              (let [n (:name binding)]
                [n {:value (emit/load builder mutable (name n))}]))
            bindings
            mutables)
       (into {})))

(defn ^:private emit-loop-ctx [ast mutables block ctx]
  (let [loads  (load-loop-bindings (:builder ctx) (:bindings ast) mutables)
        locals (update-in ctx [:env :locals] merge loads)]
    (merge locals
           {:recur-point block
            :recur-bindings mutables})))

(defmethod -compile-ast :loop [ast ctx]
  (let [builder  (:builder ctx)
        bindings (emit-loop-storage ast ctx)
        label    (name (:loop-id ast))]
    (emit/in-block builder label
      (fn [block]
        (->> (emit-loop-ctx ast bindings block ctx)
             (-compile-ast (:body ast)))))))

(defmethod -compile-ast :recur [ast ctx]
  (let [builder (:builder ctx)]
    (loop [bindings (:recur-bindings ctx)
           values   (compile-all (:exprs ast) ctx)]
      (let [binding (first bindings)
            value   (first values)]
        (when (and binding value)
          (emit/store builder binding (:value value))
          (recur (next bindings) (next values)))))
    (emit/recur* builder (:recur-point ctx))
    nil))

(defn ^:private compile-with-builder [ast ctx]
  (fn [builder]
    (:value (-compile-ast ast (assoc ctx :builder builder)))))

(defmethod -compile-ast :if [ast ctx]
  {:value
   (emit/if* (:builder ctx)
     (compile-with-builder (:test ast) ctx)
     (compile-with-builder (:then ast) ctx)
     (compile-with-builder (:else ast) ctx))})

(defn log [x]
  (println "LOG" x)
  x)

(defn ^:private emit-protocol-meth [arities]
  (->> (reduce
        (fn [v impl]
          (assoc v (inc (:arity impl)) (emit/bitcast (:value impl) emit/int8-ptr)))
        (vec (replicate 8 emit/nil*))
        arities)
       (emit/array emit/int8-ptr)
       (vector)
       (emit/struct arities-table)))

(defn swizzle-cast [type val]
  (emit/bitcast val type))

(defn ^:private emit-protocol [name id impls]
  (->> impls
       (mapv
        (fn [impl]
          (emit-protocol-meth impl)))
       (emit/array arities-table)
       (emit/global (str name "_methods"))
       (swizzle-cast (emit/ptr-of arities-table))
       (vector (emit/int emit/int32 id))
       (emit/struct dispatch-entry)))

(defn ^:private emit-protocol* [name id & impls]
  (emit-protocol name id impls))

(defn ^:private emit-type [name protocols]
  (let [type-name      (str name "_type")
        table-size     (emit/int emit/int32 (count protocols))
        protocol-table (emit/bitcast
                         (emit/global (str name "_entries")
                           (emit/array dispatch-entry protocols))
                         dispatch-table)]
    (->> (emit/struct Type [table-size protocol-table])
         (emit/global type-name Type))))

(defn ^:private emit-ctor [name type instance-struct field-types]
  (emit/define-fun! (str name "_new") emit/int8-ptr field-types
    (fn [fun builder]
      (let [instance (emit/allocate builder instance-struct)]
        (emit/set-field builder instance 0 type)
        (loop [n     0
               types field-types]
          (when-let [type (first field-types)]
            (emit/set-field builder instance (inc n) (emit/arg fun n))
            (recur (inc n) (next field-types))))
        (emit/bitcast builder instance emit/int8-ptr)))))

(defmethod -compile-ast :fn [ast ctx]
  (let [name  (name (or (:local ast) (gensym "FN")))
        qname name ;; (str (:ns @*compiler-env*) "_" name)
        meths (compile-all (:methods ast) (assoc ctx :tag qname))
        type  (emit-type qname [(emit-protocol* qname 43 meths)])
        inst  (emit/define-struct qname [(emit/type-of type)])]
    (emit-ctor qname type inst [])
    {:value (emit/new* (:builder ctx) qname [])}))

(defn ^:private emit-params [ast ctx]
  (reduce
    (fn [ctx binding]
      (let [value (emit/fn-arg (:fun ctx) (:arg-id binding))]
        (assoc-in ctx
          [:env :locals (:name binding)]
          value)))
    ctx
    (:params ast)))

(defn ^:private emit-closed-overs [ast ctx]
  ctx)

(defn ^:private arg-types [ast]
  ;; TODO: emit optimized fn types
  (cond-> (replicate (inc (count (:params ast))) emit/int8-ptr)
    ;; add one extra arg in case of a variadic fn
    (:variadic? ast) (cons emit/int8-ptr)))

(defmethod -compile-ast :fn-method [ast ctx]
  (let [name (emit/mangle (:tag ctx) ast)]
    {:arity     (:fixed-arity ast)
     :variadic? (:variadic? ast)
     :value
     (emit/define-fun! name emit/int8-ptr (arg-types ast)
       (fn [fun builder]
         (->> (fun-context fun builder)
              (emit-closed-overs ast)
              (emit-params ast)
              (-compile-ast (:body ast))
              :value)))}))

(defn ^:private load-extensions [builder type]
  (emit/get-field builder type 1))

(defn ^:private load-extension [builder extensions id]
  (emit/deref builder extensions [id emit/one]))

(defn ^:private load-dispatch-table [builder protocol idx arity]
  (emit/deref builder protocol [idx emit/zero arity]))

(defn ^:private emit-protocol-call [builder callable protocol meth arity args]
  (let [ptr (load-dispatch-table builder protocol meth arity)
        args (cons callable args)
        fun  (emit/fun-from-args builder ptr emit/int8-ptr args)]
    (emit/call builder fun args)))

(defn ^:private emit-protocol-call* [ctx callable id meth arity args]
  (let [builder (:builder ctx)]
    (emit-protocol-call builder
      callable
      (load-extension builder
        (load-extensions builder
          (emit/get-field builder callable 0))
        (emit/int emit/int32 id))
      (emit/int emit/int32 meth)
      (emit/int emit/int32 (inc arity))
      args)))

(defmethod -compile-ast :dispatch [ast ctx]
  )

(defmethod -compile-ast :deftype [ast ctx]
  )

(defmethod -compile-ast :protocol [ast ctx]
  )

(defmethod -compile-ast :def [ast ctx]
  (let [n       (:name ast)
        init    (some-> (:init ast) (-compile-ast ctx))
        builder (:builder ctx)
        global  (emit/global n (and init (emit/box builder init)))]
    (swap! *compiler-env*
           assoc-in
           [:namespaces (:ns @*compiler-env*) :mapping n :handle]
           global)
    {:value global}))

(defn ^:private emit-instrinsic*
  ([op ctx a b]
   (cond
     (= op "+")  (emit/add (:builder ctx) a b)
     (= op "-")  (emit/sub (:builder ctx) a b)
     (= op "*")  (emit/mul (:builder ctx) a b)
     (= op "/")  (emit/div (:builder ctx) a b)
     (= op "<")  (emit/cmp (:builder ctx) emit/lt a b)
     (= op "<=") (emit/cmp (:builder ctx) emit/le a b)
     (= op "==") (emit/cmp (:builder ctx) emit/eq a b)
     (= op "!=") (emit/cmp (:builder ctx) emit/ne a b)
     (= op ">")  (emit/cmp (:builder ctx) emit/gt a b)
     (= op ">=") (emit/cmp (:builder ctx) emit/ge a b))))

(defn ^:private emit-instrinsic [callable args ctx]
  (let [op (name (:field callable))]
    (apply emit-instrinsic* op ctx (map :value args))))

(defn ^:private emit-ifn-dispatch [callable-ast args ctx]
  (let [callable (:value (-compile-ast callable-ast ctx))
        arity    (count args)]
    (if (< arity 8)
      ;; callables always implement IFn as the first protocol, so we try
      ;; a dispatch to that directly
      (emit-protocol-call* ctx
        (emit/bitcast (:builder ctx) callable ValueP)
        0
        0
        arity
        (map (fn [x] (emit/box (:builder ctx) (:value x))) args))
      ;; TODO: otherwise accumulate args in last argument and call with arity 8
      ))
  ;; in fn:
  ;;   implement fixed arity call directly when args < 8
  ;;   if variadic, implement remaining arities accumulating args as list
  )

(defmethod -compile-ast :invoke [ast ctx]
  (let [callable (:fn ast)
        args     (compile-all (:args ast) ctx)]
    (cond
      (= (:class callable) 'torque.core.builtin)
        {:value (emit-instrinsic callable args ctx)}
      :else
        {:value (emit-ifn-dispatch callable args ctx)})))

(defmacro in-global-env [& body]
  `(env/ensure *compiler-env*
     ~@body))

(defn eval-ast [ast]
  ;; (print ast)
  (let [name (name (gensym "eval"))
        unit (emit/unit name)]
    (emit/with-unit unit
      (emit/define-fun! name emit/int8-ptr []
        (fn [f b]
          (-> (compile-ast ast (fun-context f b))
              (:value)))))
    (jit/register unit)
    (when-let [addr (jit/resolve-address name)]
      (invoke* addr :native []))))

(defn eval [form]
  (binding [trq/*resolver* nil
            trq/*eval*     eval-ast]
    (in-global-env
      (-> form trq/analyze eval-ast))))

;; (defn compile-ns [ns]
;;   (binding [trq/*resolver* (r/project-resolver (fs/cwd))
;;             trq/*eval*     eval]
;;     (in-global-env (trq/load-ns ns))
;;     (when-let [ast (get-in @*compiler-env* [:namespaces ns])]
;;       ;; TODO: here we would trigger a second compiler pass
;;       ;; that optimizes the code and emits an object file
;;       ;; (compile-ast ast (empty-context))
;;       nil)))
