;; -*- mode: clojure;-*-

(ns torque.compiler
  (:require
    [torque.analyzer :as a]
    [torque.analyzer.env :as env]
    [torque.analyzer.torque :as trq]
    [torque.analyzer.resolver :as r]
    [torque.compiler.jit  :as jit]
    [torque.compiler.emit :as emit]
    [torque.io.fs :as fs]))

(def ^:dynamic *compiler-env*
  "The global environment of the compiler. This holds all name
  sapce compiled so far"
  (atom (a/empty-env)))

(defn fun-context [fun]
  {:fun fun :env {:locals {}}})

(defmulti -compile-ast (fn [ast ctx] (:op ast)))

(def ^:dynamic compile-ast
  -compile-ast)

(defn compile-all [coll ctx]
  (into []
    (map
      (fn [x]
        (-compile-ast x ctx))
      coll)))

(defmethod -compile-ast :default [ast ctx])

(defmethod -compile-ast :const [ast ctx]
  {:value
   (cond
     (= (:type ast) :nil)    emit/nil*
     (= (:type ast) :bool)   (emit/bool (:val ast))
     (= (:type ast) :number) (emit/int (:val ast)))})

(defmethod -compile-ast :local [ast ctx]
  {:value
   (cond
     (= (:local ast) :field)
       (emit/get-field (emit/arg (:fun ctx) 0) (inc (:field-id ast)))
     :else
       (-> ctx :env :locals (get (:name ast))))})

(defmethod -compile-ast :var [ast ctx]
  (let [name (name (-> ast :var :name))]
    {:value
     (emit/load
       (or (emit/find-global name)
           (emit/extern name emit/int8-ptr)) name)}))

(defmethod -compile-ast :do [ast ctx]
  (loop [stmts (seq (:statements ast))]
    (when-let [stmt (first stmts)]
      (-compile-ast stmt ctx)
      (recur (next stmts))))
  (-compile-ast (:ret ast) ctx))

(defn ^:private emit-bindings [ast ctx]
  (reduce
   (fn [ctx binding]
     (let [value (-compile-ast (:init binding) ctx)]
       (assoc-in ctx [:env :locals (:name binding)] value)))
    ctx
    (:bindings ast)))

(defmethod -compile-ast :let [ast ctx]
  (-compile-ast (:body ast) (emit-bindings ast ctx)))

(defn ^:private emit-loop-storage [ast ctx]
  (mapv
    (fn [binding]
      (let [init  (-compile-ast (:init binding) ctx)
            label (name (:name binding))]
        (emit/mutable-local (:value init) label)))
    (:bindings ast)))

(defn ^:private load-loop-bindings [bindings mutables]
  (->> (map (fn [binding mutable]
              (let [n (:name binding)]
                [n {:value (emit/load mutable (name n))}]))
            bindings
            mutables)
       (into {})))

(defn ^:private emit-loop-ctx [ast mutables block ctx]
  (let [loads  (load-loop-bindings (:bindings ast) mutables)
        locals (update-in ctx [:env :locals] merge loads)]
    (merge locals
           {:recur-point block
            :recur-bindings mutables})))

(defmethod -compile-ast :loop [ast ctx]
  (let [bindings (emit-loop-storage ast ctx)
        label    (name (:loop-id ast))]
    (emit/in-block label
      (fn [block]
        (->> (emit-loop-ctx ast bindings block ctx)
             (-compile-ast (:body ast)))))))

(defmethod -compile-ast :recur [ast ctx]
  (loop [bindings (:recur-bindings ctx)
         values   (compile-all (:exprs ast) ctx)]
    (let [binding (first bindings)
          value   (first values)]
      (when (and binding value)
        (emit/store binding (:value value))
        (recur (next bindings) (next values)))))
  (emit/recur* (:recur-point ctx))
  nil)

(defn ^:private compiler [ast ctx]
  (fn [] (:value (-compile-ast ast ctx))))

(defmethod -compile-ast :if [ast ctx]
  {:value
   (emit/if*
     (compiler (:test ast) ctx)
     (compiler (:then ast) ctx)
     (compiler (:else ast) ctx))})

(defn ^:private emit-protocol-meth [arities]
  (->> (reduce
        (fn [v impl]
          (assoc v (inc (:arity impl)) (emit/bitcast (:value impl) emit/int8-ptr)))
        (vec (replicate 8 emit/nil*))
        arities)
       (emit/array emit/int8-ptr)
       (vector)
       (emit/struct emit/arities-table)))

(defn swizzle-cast [type val]
  (emit/bitcast val type))

(defn ^:private emit-protocol [name id impls]
  (->> impls
       (mapv
        (fn [impl]
          (emit-protocol-meth impl)))
       (emit/array emit/arities-table)
       (emit/global (str name "_methods"))
       (swizzle-cast (emit/ptr-of emit/arities-table))
       (vector (emit/int emit/int32 id))
       (emit/struct emit/dispatch-entry)))

(defn ^:private emit-protocol* [name id & impls]
  (emit-protocol name id impls))

(defn ^:private emit-type [name protocols]
  (let [type-name      (str name "_type")
        table-size     (emit/int emit/int32 (count protocols))
        protocol-table (emit/bitcast
                         (emit/global (str name "_entries")
                           (emit/array emit/dispatch-entry protocols))
                         emit/dispatch-table)]
    (->> (emit/struct emit/Type [table-size protocol-table])
         (emit/global type-name emit/Type))))

(defn ^:private emit-ctor [name type instance-struct field-types]
  (emit/define-fun! (str name "_new") emit/int8-ptr field-types
    (fn [fun]
      (let [instance (emit/allocate instance-struct)]
        (emit/set-field instance 0 type)
        (loop [n     0
               types field-types]
          (when-let [field-type (first types)]
            (emit/set-field instance (inc n) (emit/arg fun n))
            (recur (inc n) (next types))))
        (emit/bitcast instance emit/int8-ptr)))))

(defn ^:private call-frame [ctx tag frame-type]
  (merge ctx {:tag tag :frame frame-type}))

(defmethod -compile-ast :fn [ast ctx]
  (let [name  (name (or (:name ast) (gensym "fn")))
        qname name ;; (str (:ns @*compiler-env*) "_" name)
        inst  (emit/define-struct qname [emit/TypeP])
        meths (compile-all (:methods ast) (call-frame ctx qname inst))
        type  (emit-type qname [(emit-protocol* qname 43 meths)])]
    (emit-ctor qname type inst [])
    {:value (emit/new* qname [])}))

(defn ^:private emit-params [ast ctx]
  (reduce
    (fn [ctx binding]
      (let [value (emit/fn-arg (:fun ctx) (:arg-id binding))]
        (assoc-in ctx
          [:env :locals (:name binding)]
          value)))
    ctx
    (:params ast)))

(defn ^:private arg-types [ast ctx]
  ;; TODO: emit optimized fn types
  (cond-> (cons (emit/ptr-of (:frame ctx))
                (replicate (count (:params ast)) emit/int8-ptr))
    ;; add one extra arg in case of a variadic fn
    (:variadic? ast) (cons emit/int8-ptr)))

(defmethod -compile-ast :fn-method [ast ctx]
  (let [name (emit/mangle (:tag ctx) ast)]
    {:arity     (:fixed-arity ast)
     :variadic? (:variadic? ast)
     :value
     (emit/define-fun! name emit/int8-ptr (arg-types ast ctx)
       (fn [fun]
         (->> (fun-context fun)
              (emit-params ast)
              (-compile-ast (:body ast))
              :value)))}))

(defn ^:private load-extensions [type]
  (emit/get-field type 1))

(defn ^:private load-extension [extensions id]
  (emit/deref extensions [id emit/one]))

(defn ^:private load-dispatch-table [protocol idx arity]
  (emit/deref protocol [idx emit/zero arity]))

(defn ^:private emit-protocol-call [callable protocol meth arity args]
  (let [ptr (load-dispatch-table protocol meth arity)
        args (cons callable args)
        fun  (emit/fun-from-args ptr emit/int8-ptr args)]
    (emit/call fun args)))

(defn ^:private emit-protocol-call* [ctx callable id meth arity args]
  (emit-protocol-call callable
    (load-extension
      (load-extensions (emit/get-field callable 0))
      (emit/int emit/int32 id))
    (emit/int emit/int32 meth)
    (emit/int emit/int32 (inc arity))
    args))

(defmethod -compile-ast :dispatch [ast ctx]
  (let [;; protocol   (:value (-compile-ast (:protocol ast) ctx))
        protocol   (:var (:protocol ast))
        method     (:method ast)
        args       (compile-all (:args ast) ctx)
        self       (emit/bitcast (:value (first args)) emit/ValueP)
        type       (emit/get-field self 0)
        size       (emit/get-field type 0)
        extensions (load-extensions type)
        idx        (emit/mutable-local emit/zero "nexts")]
    {:value
     (emit/in-block "dispatch"
       (fn [block]
         (emit/if* 
           (fn []
             (->> (emit/load idx "idx")
                  (emit/cmp emit/gt size)))
           (fn []
             (emit/if* 
               (fn []
                 (let [extension (load-extension extensions idx)
                       id        (emit/get-field extensions 0)]
                   (emit/cmp emit/eq id (emit/int emit/int32 (:id protocol)))))
               (fn []
                 (let [extension (load-extension extensions (emit/load idx "idx"))]
                   (emit-protocol-call 
                     self
                     extension
                     (emit/int emit/int32 method)
                     (emit/int emit/int32 (inc (count args)))
                     (map :value args))))
               (fn []
                 (emit/store idx (emit/add (emit/load idx "") emit/one))
                 (emit/recur* block))))
           (fn []
             ;; TODO: throw
             emit/nil*))))}))

(defn ^:private resolve-protocol [protocol]
  (if (symbol? protocol)
    ;; in the repl the analyzer won't be able to resolve a protocol,
    ;; so we need to find it in the runtime
    (some-> (jit/resolve-value (:name protocol)) (meta))
    protocol))

(defn ^:private compile-methods [methods extensions ctx]
  (map
    (fn [x]
      (let [meth     (first x)
            tag      (str name "_" meth)
            meth-ctx (assoc ctx :tag tag)]
        (compile-all (get methods meth) meth-ctx)))
    methods))

(defn ^:private compile-extensions [extensions ctx]
  (mapv
    (fn [extension]
      (let [protocol (resolve-protocol (:protocol extension))
            methods  (:methods extension)]
        (->> (compile-methods methods (:meths protocol ctx))
             (emit-protocol (:name protocol) (:id protocol)))))
    extensions))

(defmethod -compile-ast :deftype [ast ctx]
  (let [name      (name (:name ast))
        fields    (replicate (count (:fields ast)) (emit/type emit/int8-ptr))
        inst      (emit/define-struct name (vec (cons emit/TypeP fields)))
        meth-ctx  (assoc ctx :frame inst)
        protocols (compile-extensions (:extensions ast) meth-ctx)
        type      (emit-type name protocols)]
    (emit-ctor name type inst fields)
    {:value emit/nil*}))

(defmethod -compile-ast :new [ast ctx]
  {:value
   (emit/new*
     (name (-> ast :class :var :name))
     (map :value (compile-all (:args ast) ctx)))})

(defmethod -compile-ast :protocol [ast ctx]
  (let [instance (->> [(emit/int emit/int32 (:id ast))]
                      (emit/struct emit/Protocol)
                      (emit/global (name (:name ast))))]
    {:value instance}))

(defmethod -compile-ast :def [ast ctx]
  (let [n       (:name ast)
        init    (:value (some-> (:init ast) (-compile-ast ctx)))
        global  (emit/global (name n) emit/nil*)]
    (emit/store global (and init (emit/box init)))
    {:value global}))

(defn ^:private emit-instrinsic*
  ([op ctx x]
   (cond
     (= op "integer?") nil
     (= op "binary?")  emit/nil*
     (= op "array?")   emit/nil*
     (= op "type")     nil))
  ([op ctx a b]
   (cond
     ;; intrinsic operators
     (= op "+")  (emit/add a b)
     (= op "-")  (emit/sub a b)
     (= op "*")  (emit/mul a b)
     (= op "/")  (emit/div a b)
     (= op "<")  (emit/cmp emit/lt a b)
     (= op "<=") (emit/cmp emit/le a b)
     (= op "==") (emit/cmp emit/eq a b)
     (= op "!=") (emit/cmp emit/ne a b)
     (= op ">")  (emit/cmp emit/gt a b)
     (= op ">=") (emit/cmp emit/ge a b)
     ;; (= op "+")  (emit/band (:builder ctx) a b)
     ;; (= op "-")  (emit/bor  (:builder ctx) a b)
     ;; (= op "*")  (emit/bsl  (:builder ctx) a b)
     ;; (= op "/")  (emit/bsr  (:builder ctx) a b)
     ;; builtin functions
     (= op "identical?") (emit/identical a b)
     (= op "satisfies?") nil)))

(defn ^:private emit-instrinsic [callable args ctx]
  (let [op (name (:field callable))]
    (apply emit-instrinsic* op ctx (map :value args))))

(defn ^:private emit-ifn-dispatch [callable-ast args ctx]
  (let [callable (:value (-compile-ast callable-ast ctx))
        arity    (count args)]
    (if (< arity 8)
      ;; callables always implement IFn as the first protocol, so we try
      ;; a dispatch to that directly
      (emit-protocol-call* ctx
        (emit/bitcast callable emit/ValueP)
        0
        0
        arity
        (map (fn [x] (emit/box (:value x))) args))
      ;; TODO: otherwise accumulate args in last argument and call with arity 8
      ))
  ;; in fn:
  ;;   implement fixed arity call directly when args < 8
  ;;   if variadic, implement remaining arities accumulating args as list
  )

(defn ^:private builtin? [x]
  (= (:class x) 'torque.core.builtin))

(defmethod -compile-ast :invoke [ast ctx]
  (let [callable (:fn ast)
        args     (compile-all (:args ast) ctx)]
    {:value
     (cond
       (builtin? callable) (emit-instrinsic callable args ctx)
       ;; TODO: optimize call if it is known to be a fn
       :else               (emit-ifn-dispatch callable args ctx))}))

(defmacro in-global-env [& body]
  `(env/ensure *compiler-env*
     ~@body))

(defn eval-ast [ast]
  ;; (print ast)
  (let [name (name (gensym "eval"))
        unit (emit/unit name)]
    (emit/with-unit unit
      (emit/define-fun! name emit/int8-ptr []
        (fn [f]
          (-> (compile-ast ast (fun-context f))
              (:value)))))
    (jit/register unit)
    (when-let [addr (jit/resolve-address name)]
      (invoke* addr :native []))))

(defn eval [form]
  (binding [trq/*resolver* nil
            trq/*eval*     eval-ast]
    (in-global-env
      (-> form trq/analyze eval-ast))))

;; (defn compile-ns [ns]
;;   (binding [trq/*resolver* (r/project-resolver (fs/cwd))
;;             trq/*eval*     eval]
;;     (in-global-env (trq/load-ns ns))
;;     (when-let [ast (get-in @*compiler-env* [:namespaces ns])]
;;       ;; TODO: here we would trigger a second compiler pass
;;       ;; that optimizes the code and emits an object file
;;       ;; (compile-ast ast (empty-context))
;;       nil)))
