;; -*- mode: clojure;-*-

(ns torque.compiler
  (:require
    [torque.analyzer :as a]
    [torque.analyzer.env :as env]
    [torque.analyzer.torque :as trq]
    [torque.analyzer.resolver :as r]
    [torque.compiler.builtins :as builtin]
    [torque.compiler.emit :as emit]
    [torque.compiler.generators :as gen]
    [torque.compiler.jit :as jit]
    [torque.compiler.runtime :as rt]
    [torque.io.fs :as fs]))

(def ^:dynamic *compiler-env*
  "The global environment of the compiler. This holds all name
  sapce compiled so far"
  (atom (a/empty-env)))

(defn throw-not-a-constant-type [ast]
  (throw
    (ex-info (str (:type ast) " is not a constant type")
      {:type (:type ast)
       :form (:form ast)})))

(defn fun-context [fun]
  {:fun fun :env {:locals {}}})

(defmulti -compile-ast (fn [ast ctx] (:op ast)))

(def ^:dynamic compile-ast
  -compile-ast)

(defn compile-all [coll ctx]
  (into []
    (map
      (fn [x]
        (-compile-ast x ctx))
      coll)))

(defn make-vector [values]
  (let [type     (emit/import-type "torque_lang_vector_PersistentVector")
        protocol (gen/find-protocol type (emit/int emit/int32 rt/coll))]
    (reduce
      (fn [v val]
        (gen/emit-protocol-call v
          protocol
          emit/zero
          (emit/int emit/int32 2)
          [v (emit/box (:value val))]))
      (emit/extern (str "torque_lang_vector_empty") emit/ValueP)
      values)))

(defmethod -compile-ast :default [ast ctx])

(defmethod -compile-ast :const [ast ctx]
  {:value
    (cond
      (= (:type ast) :nil)    emit/nil*
      (= (:type ast) :bool)   (emit/bool (:val ast))
      (= (:type ast) :number) (emit/int (:val ast))
      (= (:type ast) :string) (builtin/make-string (:val ast))
      (= (:type ast) :symbol) (builtin/make-symbol (:val ast))
      :else (throw-not-a-constant-type ast))})

(defmethod -compile-ast :vector [ast ctx]
  {:value (make-vector (compile-all (:items ast) ctx))})

(defmethod -compile-ast :quote [ast ctx]
  (-compile-ast (:expr ast) ctx))

(defmethod -compile-ast :local [ast ctx]
  {:value
   (cond
     (= (:local ast) :field)
       (emit/get-field (emit/arg (:fun ctx) 0) (inc (:field-id ast)))
     :else
       (-> ctx :env :locals (get (:name ast))))})

(defmethod -compile-ast :var [ast ctx]
  (let [name (name (-> ast :var :name))]
    {:value (emit/load (emit/extern name emit/ValueP) name)}))

(defmethod -compile-ast :do [ast ctx]
  (loop [stmts (seq (:statements ast))]
    (when-let [stmt (first stmts)]
      (-compile-ast stmt ctx)
      (recur (next stmts))))
  (-compile-ast (:ret ast) ctx))

(defn ^:private emit-bindings [ast ctx]
  (reduce
    (fn [ctx binding]
      (let [value (-compile-ast (:init binding) ctx)]
        (assoc-in ctx [:env :locals (:name binding)] (:value value))))
   ctx
   (:bindings ast)))

(defmethod -compile-ast :let [ast ctx]
  (-compile-ast (:body ast) (emit-bindings ast ctx)))

(defn ^:private emit-loop-storage [ast ctx]
  (mapv
    (fn [binding]
      (let [init  (-compile-ast (:init binding) ctx)
            label (name (:name binding))]
        (emit/mutable-local (:value init) label)))
    (:bindings ast)))

(defn ^:private load-loop-bindings [bindings mutables]
  (->> (map (fn [binding mutable]
              (let [n (:name binding)]
                [n (emit/load mutable (name n))]))
            bindings
            mutables)
       (into {})))

(defn ^:private emit-loop-ctx [ast mutables block ctx]
  (let [loads  (load-loop-bindings (:bindings ast) mutables)
        locals (update-in ctx [:env :locals] merge loads)]
    (merge locals
           {:recur-point block
            :recur-bindings mutables})))

(defmethod -compile-ast :loop [ast ctx]
  (let [bindings (emit-loop-storage ast ctx)
        label    (name (:loop-id ast))]
    (emit/in-block label
      (fn [block]
        (->> (emit-loop-ctx ast bindings block ctx)
             (-compile-ast (:body ast)))))))

(defmethod -compile-ast :recur [ast ctx]
  (loop [bindings (:recur-bindings ctx)
         values   (compile-all (:exprs ast) ctx)]
    (let [binding (first bindings)
          value   (first values)]
      (when (and binding value)
        (emit/store binding (:value value))
        (recur (next bindings) (next values)))))
  (emit/recur* (:recur-point ctx))
  nil)

(defn ^:private compiler [ast ctx]
  (fn [] (:value (-compile-ast ast ctx))))

(defmethod -compile-ast :if [ast ctx]
  {:value
   (emit/if*
     (compiler (:test ast) ctx)
     (compiler (:then ast) ctx)
     (compiler (:else ast) ctx))})

(defn ^:private call-frame [ctx tag frame-type]
  (merge ctx {:tag tag :frame frame-type}))

(defn ^:private add-fn-frame [methods ctx]
  (map (fn [meth]
         (update-in meth [:params]
                    (fn [params]
                      (cons {:name 'frame
                             :arg-id 0
                             :type (emit/ptr-of (:frame ctx))}
                            (map (fn [param]
                                   (update param :arg-id inc))
                                 params)))))
       methods))

(defmethod -compile-ast :fn [ast ctx]
  (let [name      (name (or (:name ast) (gensym "fn")))
        qname     name ;; (str (:ns @*compiler-env*) "_" name)
        max-arity (:max-fixed-arity ast)
        type      (gen/type qname []
                    (fn [type]
                      (let [ctx   (call-frame ctx qname type)
                            meths (add-fn-frame (:methods ast) ctx)]
                        (->> (compile-all meths ctx)
                             (gen/protocol* qname rt/ifn)
                             (list)))))]
    {:value (emit/new* qname [])}))

(defn ^:private emit-params [ast ctx]
  (reduce
    (fn [ctx binding]
      (let [value (emit/arg (:fun ctx) (:arg-id binding))]
        (assoc-in ctx
          [:env :locals (:name binding)]
          value)))
    ctx
    (:params ast)))

(defn ^:private emit-fn-local [ast ctx]
  (if (:local ast)
    (->> (emit/arg (:fun ctx) 0)
         (assoc-in ctx [:locals (:name (:local ast))]))
    ctx))

(defn ^:private arg-types [ast ctx]
  (let [args (map (fn [x] (:type x emit/ValueP)) (:params ast))]
    (if (:variadic? ast)
      ;; add one extra arg in case of a variadic fn
      (cons emit/ValueP args)
      args)))

(defmethod -compile-ast :fn-method [ast ctx]
  (let [name (emit/mangle (:tag ctx) ast)]
    {:arity     (:fixed-arity ast)
     :variadic? (:variadic? ast)
     :value
     (emit/define-fun! name emit/ValueP (arg-types ast ctx)
       (fn [fun]
         (->> (fun-context fun)
              (emit-fn-local ast)
              (emit-params ast)
              (-compile-ast (:body ast))
              :value)))}))

(defn satisfies [protocol x]
  (let [protocol (emit/bitcast protocol emit/ProtoP)]
    (emit/cmp emit/ne
      (gen/find-protocol (emit/get-field x 0) (emit/get-field protocol 1))
      emit/not-implemented)))

(defmethod -compile-ast :dispatch [ast ctx]
  (let [;; protocol   (:value (-compile-ast (:protocol ast) ctx))
        protocol   (:var (:var (:protocol ast)))
        method     (:method ast)
        args       (compile-all (:args ast) ctx)
        self       (emit/bitcast (:value (first args)) emit/ValueP)
        type       (emit/get-field self 0)
        extension  (gen/find-protocol type (emit/int emit/int32 (:id protocol)))]
    {:value
      (gen/emit-protocol-call
         self
         extension
         (emit/int emit/int32 method)
         (emit/int emit/int32 (count args))
         (map :value args))}))

(defn ^:private resolve-protocol [protocol]
  (if (symbol? protocol)
    ;; in the repl the analyzer won't be able to resolve a protocol,
    ;; so we need to find it in the runtime
    (some-> (jit/resolve-value (:name protocol)) (meta))
    protocol))

(defn ^:private compile-methods [name methods extensions ctx]
  (map
    (fn [x]
      (let [meth     (first x)
            tag      (str name "_" meth)
            meth-ctx (assoc ctx :tag tag)]
        (map (fn [x]
               (update-in x [:arity] dec))
             (compile-all (map (fn [x]
                                 (update-in x [:params 0]
                                            assoc
                                            :type
                                            (emit/ptr-of (:frame ctx))))
                               (get methods meth))
                          meth-ctx))))
    methods))

(defn ^:private compile-extensions [name extensions ctx]
  (mapv
    (fn [extension]
      (let [protocol (resolve-protocol (:var (:protocol extension)))
            methods  (:methods extension)]
        (->> (compile-methods name methods (:meths protocol ctx) ctx)
             (gen/protocol (:name protocol) (:id protocol)))))
    extensions))

(defmethod -compile-ast :deftype [ast ctx]
  (let [name (name (:name ast))
        type (gen/type name (:fields ast)
               (fn [type]
                 (->> (assoc ctx :frame type)
                      (compile-extensions name (:extensions ast)))))]
    {:value emit/nil*}))

(defmethod -compile-ast :type-field [ast ctx]
  (let [val       (:value (-compile-ast (:target ast) ctx))
        type (emit/get-field val 0)
        field-fun (emit/get-field type 3)
        s (emit/global ".field" (emit/string (name (:field ast))))]
    {:value (emit/call field-fun [val s])}))

(defmethod -compile-ast :new [ast ctx]
  {:value
   (emit/new*
     (name (-> ast :class :var :name))
     (map (fn [x] (emit/box (:value x))) (compile-all (:args ast) ctx)))})

(defmethod -compile-ast :protocol [ast ctx]
  (let [name     (str (name (:name ast)) "_protocol")
        instance (->> [(emit/null emit/TypeP) (emit/int emit/int32 (:id ast))]
                      (emit/struct emit/Protocol)
                      (emit/global name))]
    {:value (emit/bitcast instance emit/ValueP)}))

(defmethod -compile-ast :def [ast ctx]
  (let [n     (:name ast)
        init  (:init ast)
        global (emit/global (name n) emit/nil*)
        value (some-> init (-compile-ast ctx))]
    (emit/store global (and value (emit/box (:value value))))
    (or value {:value emit/nil*})))

(defn ^:private emit-instrinsic*
  ([op ctx x]
   (cond
     ;; (= op "integer?")    (emit/integer? x)
     (= op "binary?")     (emit/instance-of (builtin/binary) x)
     (= op "array?")      (emit/instance-of (builtin/array) x)
     (= op "type")        (emit/value-type (emit/box x))
     (= op "make-binary") (builtin/make-binary (emit/unbox x))
     (= op "blength")     (builtin/blength x)
     (= op "make-array")  (builtin/make-array (emit/unbox x))
     (= op "alength")     (builtin/alength x)
     (= op "print")       (emit/print x)))
  ([op ctx a b]
   (cond
     ;; operator intrinsics
     (= op "+")   (emit/add a b)
     (= op "-")   (emit/sub a b)
     (= op "*")   (emit/mul a b)
     (= op "/")   (emit/div a b)
     (= op "<")   (emit/cmp emit/lt (emit/unbox a) (emit/unbox b))
     (= op "<=")  (emit/cmp emit/le (emit/unbox a) (emit/unbox b))
     (= op "==")  (emit/cmp emit/eq (emit/unbox a) (emit/unbox b))
     (= op "!=")  (emit/cmp emit/ne (emit/unbox a) (emit/unbox b))
     (= op ">")   (emit/cmp emit/gt (emit/unbox a) (emit/unbox b))
     (= op ">=")  (emit/cmp emit/ge (emit/unbox a) (emit/unbox b))
     (= op "&")   (emit/bit-and a b)
     (= op "|")   (emit/bit-or a b)
     (= op "bsl") (emit/bsl a b)
     (= op "bsr") (emit/bsr a b)
     ;; builtin functions
     (= op "identical?") (emit/identical a b)
     (= op "satisfies?") (satisfies a b)
     (= op "bget")       (builtin/bget a (emit/unbox b))
     (= op "aget")       (builtin/aget a (emit/unbox b))))
  ([op ctx a b c]
   (cond
     (= op "aset") (builtin/aset a (emit/unbox b) c))))

(defn ^:private emit-instrinsic [callable args ctx]
  (let [op (name (:field callable))]
    (apply emit-instrinsic* op ctx (map :value args))))

(defn ^:private emit-ifn-dispatch [callable-ast args ctx]
  (let [callable (:value (-compile-ast callable-ast ctx))
        arity    (count args)]
    (if (< arity 8)
      ;; callables always implement IFn as the first protocol, so we try
      ;; a dispatch to that directly
      (gen/emit-protocol-call*
        (emit/bitcast callable emit/ValueP)
        0
        0
        arity
        (map (fn [x] (emit/box (:value x))) args))
      ;; TODO: otherwise accumulate args in last argument and call with arity 8
      )))

(defn ^:private builtin? [x]
  (= (:class x) 'torque.core.builtin))

(defmethod -compile-ast :invoke [ast ctx]
  (let [callable (:fn ast)
        args     (compile-all (:args ast) ctx)]
    {:value
     (cond
       (builtin? callable) (emit-instrinsic callable args ctx)
       ;; TODO: optimize call if it is known to be a fn
       :else               (emit-ifn-dispatch callable args ctx))}))

(defmacro in-global-env [& body]
  `(env/ensure *compiler-env*
     ~@body))

(defn eval-ast [ast]
  ;; (print ast)
  (let [jit  (jit/singleton)
        name (name (gensym "eval"))
        unit (emit/unit name)]
    (emit/with-unit unit
      (emit/define-fun! name emit/ValueP []
        (fn [f]
          (-> (compile-ast ast (fun-context f))
              (:value)))))
    (jit/register unit)
    (when-let [addr (jit/resolve-address name)]
      addr)))

(defn eval [form]
  (binding [trq/*resolver* nil
            trq/*eval*     eval-ast]
    (in-global-env
      (-> form trq/analyze eval-ast))))

(defn compile-ns [ns]
  (binding [trq/*resolver* (r/project-resolver (fs/cwd))
            trq/*eval*     eval-ast]
    (in-global-env (trq/load-ns ns))
    (when-let [ast (get-in @*compiler-env* [:namespaces ns])]
      ;; TODO: here we would trigger a second compiler pass
      ;; that optimizes the code and emits an object file
      ;; (compile-ast ast (empty-context))
      nil)))
