;; -*- mode: clojure;-*-

(ns torque.compiler
  (:require
    [torque.analyzer :as a]
    [torque.analyzer.env :as env]
    [torque.analyzer.utils :as u]
    [torque.analyzer.torque :as trq]
    [torque.analyzer.resolver :as r]
    [torque.compiler.builtins :as builtin]
    [torque.compiler.emit :as emit]
    [torque.compiler.generators :as gen]
    [torque.compiler.jit :as jit]
    [torque.compiler.runtime :as rt]
    [torque.io.fs :as fs]))

(def ^:dynamic *compiler-env*
  "The global environment of the compiler. This holds all name
  sapce compiled so far"
  (atom (a/empty-env)))

(defn throw-not-a-constant [val]
  (throw
    (ex-info (str val " is not a constant value")
      {:value val})))

(defn throw-not-a-constant-type [ast]
  (throw
    (ex-info (str (:type ast) " is not a constant type")
      {:type (:type ast)
       :form (:form ast)})))

(defn fun-context [fun]
  {:fun fun :env {:locals {}}})

(defmulti -compile-ast (fn [ast ctx] (:op ast)))

(def ^:dynamic compile-ast
  -compile-ast)

(defn compile-all [coll ctx]
  (into []
    (map
      (fn [x]
        (-compile-ast x ctx))
      coll)))

(defn ^:private empty-coll [t]
  (-> (str "torque_lang_" t "_empty")
      (emit/extern emit/ValueP)
      (emit/load (str "empty_" t))))

(defn into-coll
  [type values empty-coll]
  (if (empty? values)
    empty-coll
    (let [protocol (gen/find-protocol type (emit/int emit/int32 rt/coll))]
      (reduce
       (fn [v val]
         (gen/emit-protocol-call v
           protocol
           emit/zero
           (emit/int emit/int32 2)
           [v (emit/box (:value val))]))
       empty-coll
       values))))

(defn make-vector [values]
  (let [empty-vector (empty-coll "vector")
        type         (builtin/vector)]
    (into-coll type values empty-vector)))

(defn make-set [values]
  (let [empty-set (empty-coll "set")
        type      (builtin/set)]
    (into-coll type values empty-set)))

(defn make-map [kvs]
  (let [empty-map (empty-coll "map")]
    (if (empty? kvs)
      empty-map
      (let [type     (emit/import-type builtin/map-type-name)
            protocol (gen/find-protocol type (emit/int emit/int32 rt/associative))]
        (reduce
          (fn [m kv]
            (gen/emit-protocol-call m
              protocol
              emit/one
              (emit/int emit/int32 3)
              [m
               (emit/box (:value (first kv)))
               (emit/box (:value (second kv)))]))
          empty-map
          kvs)))))

(defn make-const [val]
  (cond
    (nil? val)     emit/nil*
    (boolean? val) (emit/bool val)
    (integer? val) (emit/int val)
    (string? val)  (builtin/make-string val)
    (symbol? val)  (builtin/make-symbol val)
    (keyword? val) (builtin/make-keyword val)
    (vector? val)  (make-vector (map make-const val))
    (set? val)     (make-set (map make-const val))
    :else (throw-not-a-constant val)))

(defmethod -compile-ast :default [ast ctx]
  (print "DEFAULT")
  (print (:form ast))
  (throw (ex-info "Unknown operation" {:op (:op ast) :ast ast})))

(defmethod -compile-ast :const [ast ctx]
  {:value
    (cond
      (= (:type ast) :nil)     emit/nil*
      (= (:type ast) :bool)    (emit/bool (:val ast))
      (= (:type ast) :number)  (emit/int (:val ast))
      (= (:type ast) :string)  (builtin/make-string (:val ast))
      (= (:type ast) :symbol)  (builtin/make-symbol (:val ast))
      (= (:type ast) :keyword) (builtin/make-keyword (:val ast))
      (= (:type ast) :vector)  (make-const (:val ast))
      (= (:type ast) :set)     (make-const (:val ast))
      :else (throw-not-a-constant-type ast))})

(defmethod -compile-ast :vector [ast ctx]
  {:value (-> (compile-all (:items ast) ctx) make-vector)})

(defmethod -compile-ast :set [ast ctx]
  {:value (-> (compile-all (:items ast) ctx) make-set)})

(defmethod -compile-ast :map [ast ctx]
  (let [ks (compile-all (:keys ast) ctx)
        vs (compile-all (:vals ast) ctx)]
    {:value (make-map (map vector ks vs))}))

(defmethod -compile-ast :quote [ast ctx]
  (-compile-ast (:expr ast) ctx))

(defmethod -compile-ast :local [ast ctx]
  {:value
   (cond
     (= (:local ast) :field)
       (emit/get-field (emit/arg (:fun ctx) 0) (inc (:field-id ast)))
     :else
       (-> ctx :env :locals (get (:name ast))))})

(defmethod -compile-ast :var [ast ctx]
  (let [name (emit/mangle-var (:var ast))]
    {:value (emit/load (emit/extern name emit/ValueP) name)}))

(defmethod -compile-ast :do [ast ctx]
  (loop [stmts (seq (:statements ast))]
    (when-let [stmt (first stmts)]
      (-compile-ast stmt ctx)
      (recur (next stmts))))
  (-compile-ast (:ret ast) ctx))

(defn ^:private emit-bindings [ast ctx]
  (reduce
    (fn [ctx binding]
      (let [value (-compile-ast (:init binding) ctx)]
        (assoc-in ctx [:env :locals (:name binding)] (:value value))))
   ctx
   (:bindings ast)))

(defmethod -compile-ast :let [ast ctx]
  (-compile-ast (:body ast) (emit-bindings ast ctx)))

(defn ^:private emit-loop-storage [ast ctx]
  (mapv
    (fn [binding]
      (let [init  (-compile-ast (:init binding) ctx)
            label (name (:name binding))]
        (emit/mutable-local (:value init) label)))
    (:bindings ast)))

(defn ^:private load-loop-bindings [bindings mutables]
  (->> (map (fn [binding mutable]
              (let [n (:name binding)]
                [n (emit/load mutable (name n))]))
            bindings
            mutables)
       (into {})))

(defn ^:private emit-loop-ctx [ast mutables block ctx]
  (let [loads  (load-loop-bindings (:bindings ast) mutables)
        locals (update-in ctx [:env :locals] merge loads)]
    (merge locals
           {:recur-point block
            :recur-bindings mutables})))

(defmethod -compile-ast :loop [ast ctx]
  (let [bindings (emit-loop-storage ast ctx)
        label    (name (:loop-id ast))]
    (emit/in-block label
      (fn [block]
        (->> (emit-loop-ctx ast bindings block ctx)
             (-compile-ast (:body ast)))))))

(defmethod -compile-ast :recur [ast ctx]
  (loop [bindings (:recur-bindings ctx)
         values   (compile-all (:exprs ast) ctx)]
    (let [binding (first bindings)
          value   (first values)]
      (when (and binding value)
        (emit/store binding (:value value))
        (recur (next bindings) (next values)))))
  (emit/recur* (:recur-point ctx))
  nil)

(defn ^:private compiler [ast ctx]
  (fn [] (:value (-compile-ast ast ctx))))

(defmethod -compile-ast :if [ast ctx]
  {:value
   (emit/if*
     (compiler (:test ast) ctx)
     (compiler (:then ast) ctx)
     (compiler (:else ast) ctx))})

(defn ^:private call-frame [ctx tag frame-type]
  (merge ctx {:tag tag :frame frame-type}))

(defn ^:private add-fn-frame [methods ctx]
  (map (fn [meth]
         (update-in meth [:params]
           (fn [params]
             (cons {:name   'frame
                    :arg-id 0
                    :type   (emit/ptr-of (:frame ctx))}
                   (map (fn [param]
                          (update param :arg-id inc))
                        params)))))
       methods))

(defn ^:private closed-over-types [ast]
  (map
   (fn [sym id]
     {:type     emit/ValueP
      :field-id id
      :name     sym})
   (:closing-over ast)
   (iterate inc 0)))

(defn ^:private emit-closed-overs [parent-ctx ctx]
  (reduce
    (fn [ctx [sym id]]
      (assoc-in ctx [:env :locals sym]
        (emit/get-field (emit/arg (:fun ctx) 0) (inc id))))
    ctx
    (map vector (:closed-overs parent-ctx) (iterate inc 0))))

(defmethod -compile-ast :fn [ast ctx]
  (let [qname     (str (:tag ctx) "_" (or (:name ast) (gensym "fn")))
        max-arity (:max-fixed-arity ast)
        fields    (closed-over-types ast)
        meth-ctx  (assoc ctx :closed-overs (vec (:closing-over ast)))
        type      (gen/type qname fields
                    (fn [type]
                      (let [meth-ctx (call-frame meth-ctx qname type)
                            meths    (add-fn-frame (:methods ast) meth-ctx)]
                        (->> (compile-all meths meth-ctx)
                             (gen/protocol* qname rt/ifn)
                             (list)))))
        enclosed  (mapv
                    (fn [x]
                      (-> ctx :env :locals (get x)))
                    (:closing-over ast))]
    {:value (emit/new* qname (map emit/box enclosed))}))

(defn ^:private emit-params [ast ctx]
  (reduce
    (fn [ctx binding]
      (let [value (emit/arg (:fun ctx) (:arg-id binding))]
        (assoc-in ctx
          [:env :locals (:name binding)]
          value)))
    ctx
    (:params ast)))

(defn ^:private emit-fn-local [ast ctx]
  (if (:local ast)
    (->> (emit/arg (:fun ctx) 0)
         (assoc-in ctx [:env :locals (:name (:local ast))]))
    ctx))

(defn ^:private arg-types [ast ctx]
  (let [args (mapv (fn [x] (:type x emit/ValueP)) (:params ast))]
    (if (:variadic? ast)
      ;; add one extra arg in case of a variadic fn
      (conj args emit/ValueP)
      args)))

(defmethod -compile-ast :fn-method [ast ctx]
  (let [name (emit/mangle (:tag ctx) ast)]
    {:arity     (:fixed-arity ast)
     :variadic? (:variadic? ast)
     :value
     (emit/define-fun! name emit/ValueP (arg-types ast ctx)
       (fn [fun]
         (->> (assoc (fun-context fun) :tag (:tag ctx))
              (emit-fn-local ast)
              (emit-closed-overs ctx)
              (emit-params ast)
              (-compile-ast (:body ast))
              :value)))}))

(defn satisfies [protocol x]
  (let [protocol (emit/bitcast protocol emit/ProtoP)]
    (emit/cmp emit/ne
      (gen/find-protocol (emit/get-field x 0) (emit/get-field protocol 1))
      emit/not-implemented)))

(defmethod -compile-ast :dispatch [ast ctx]
  (let [;; protocol   (:value (-compile-ast (:protocol ast) ctx))
        protocol   (:var (:var (:protocol ast)))
        method     (:method ast)
        args       (compile-all (:args ast) ctx)
        self       (emit/bitcast (:value (first args)) emit/ValueP)
        type       (emit/get-field self 0)
        extension  (gen/find-protocol type (emit/int emit/int32 (:id protocol)))]
    {:value
      (gen/emit-protocol-call
         self
         extension
         (emit/int emit/int32 method)
         (emit/int emit/int32 (count args))
         (map :value args))}))

(defn ^:private resolve-protocol [protocol]
  (if (symbol? protocol)
    ;; in the repl the analyzer won't be able to resolve a protocol,
    ;; so we need to find it in the runtime
    (some-> (jit/resolve-value (:name protocol)) (meta))
    protocol))

(defn ^:private compile-methods [name methods extensions ctx]
  (map
    (fn [x]
      (let [meth     (first x)
            tag      (str name "_" meth)
            meth-ctx (assoc ctx :tag tag)]
        (map (fn [x]
               (update-in x [:arity] dec))
             (compile-all (map (fn [x]
                                 (update-in x [:params 0]
                                            assoc
                                            :type
                                            (emit/ptr-of (:frame ctx))))
                               (get methods meth))
                          meth-ctx))))
    methods))

(defn ^:private compile-extensions [name extensions ctx]
  (mapv
    (fn [extension]
      (let [protocol (resolve-protocol (:var (:protocol extension)))
            methods  (:methods extension)]
        (->> (compile-methods name methods (:meths protocol ctx) ctx)
             (gen/protocol (:name protocol) (:id protocol)))))
    extensions))

(defmethod -compile-ast :deftype [ast ctx]
  (let [qname (str (:tag ctx) "_" (:name ast))
        type  (gen/type qname (:fields ast)
                (fn [type]
                  (->> (assoc ctx :frame type)
                       (compile-extensions qname (:extensions ast)))))]
    {:value emit/nil*}))

(defmethod -compile-ast :type-field [ast ctx]
  (let [val       (:value (-compile-ast (:target ast) ctx))
        type      (emit/get-field val 0)
        field-fun (emit/get-field type 3)
        s (emit/global ".field" (emit/string (name (:field ast))))]
    {:value (emit/call field-fun [val s])}))

(defmethod -compile-ast :set! [ast ctx]
  (let [target (:value (-compile-ast (:target ast) ctx))
        val    (:value (-compile-ast (:val ast) ctx))
        setter (emit/get-field (emit/value-type target) emit/type-set-field)
        s      (emit/global ".field" (emit/string (name (:field ast))))]
    (emit/call setter [target s (emit/box val)])
    {:value emit/nil*}))

(defmethod -compile-ast :new [ast ctx]
  {:value
   (emit/new*
     (emit/mangle-var (-> ast :class :var))
     (map (fn [x] (emit/box (:value x))) (compile-all (:args ast) ctx)))})

(defmethod -compile-ast :protocol [ast ctx]
  (let [name     (str (:tag ctx) "_" (name (:name ast)) "_protocol")
        instance (->> [(emit/null emit/TypeP) (emit/int emit/int32 (:id ast))]
                      (emit/struct emit/Protocol)
                      (emit/global name))]
    {:value (emit/bitcast instance emit/ValueP)}))

(defmethod -compile-ast :def [ast ctx]
  (let [qname  (emit/mangle-var (:var ast))
        init   (:init ast)
        global (if (jit/resolve-address qname)
                 (emit/extern qname emit/ValueP)
                 (or (emit/find-global qname) (emit/global qname emit/nil*)))
        value  (some-> init (-compile-ast ctx))]
    (when value
      (emit/store global (and value (emit/box (:value value))))
      value)
    {:value emit/nil*}))

(defn ^:private emit-instrinsic*
  ([op ctx x]
   (cond
     ;; (= op "integer?")    (emit/integer? x)
     (= op "binary?")     (emit/instance-of (builtin/binary) x)
     (= op "array?")      (emit/instance-of (builtin/array) x)
     (= op "type")        (emit/value-type (emit/box x))
     (= op "make-binary") (builtin/make-binary (emit/unbox x))
     (= op "blength")     (builtin/blength x)
     (= op "make-array")  (builtin/make-array (emit/unbox x))
     (= op "alength")     (builtin/alength x)
     (= op "print")       (emit/print x)))
  ([op ctx a b]
   (cond
     ;; operator intrinsics
     (= op "+")   (emit/add a b)
     (= op "-")   (emit/sub a b)
     (= op "*")   (emit/mul a b)
     (= op "/")   (emit/div a b)
     (= op "<")   (emit/cmp emit/lt (emit/unbox a) (emit/unbox b))
     (= op "<=")  (emit/cmp emit/le (emit/unbox a) (emit/unbox b))
     (= op "==")  (emit/cmp emit/eq (emit/unbox a) (emit/unbox b))
     (= op "!=")  (emit/cmp emit/ne (emit/unbox a) (emit/unbox b))
     (= op ">")   (emit/cmp emit/gt (emit/unbox a) (emit/unbox b))
     (= op ">=")  (emit/cmp emit/ge (emit/unbox a) (emit/unbox b))
     (= op "&")   (emit/bit-and a b)
     (= op "|")   (emit/bit-or a b)
     (= op "bsl") (emit/bsl a b)
     (= op "bsr") (emit/bsr a b)
     ;; builtin functions
     (= op "identical?") (emit/identical a b)
     (= op "satisfies?") (satisfies a b)
     (= op "bget")       (builtin/bget a (emit/unbox b))
     (= op "aget")       (builtin/aget a (emit/unbox b))))
  ([op ctx a b c]
   (cond
     (= op "aset") (builtin/aset a (emit/unbox b) c))))

(defn ^:private emit-instrinsic [callable args ctx]
  (let [op (name (:field callable))]
    (apply emit-instrinsic* op ctx (map :value args))))

(defn ^:private emit-ifn-dispatch [callable-ast args ctx]
  (let [callable (:value (-compile-ast callable-ast ctx))
        arity    (count args)]
    (if (< arity 8)
      ;; callables always implement IFn as the first protocol, so we try
      ;; a dispatch to that directly
      (gen/emit-protocol-call*
        (emit/bitcast callable emit/ValueP)
        0
        0
        arity
        (map (fn [x] (emit/box (:value x))) args))
      ;; TODO: otherwise accumulate args in last argument and call with arity 8
      emit/nil*)))

(defn ^:private builtin? [x]
  (= (:class x) 'torque.core.builtin))

(defmethod -compile-ast :invoke [ast ctx]
  (let [callable (:fn ast)
        args     (compile-all (:args ast) ctx)]
    {:value
     (cond
       (builtin? callable) (emit-instrinsic callable args ctx)
       ;; TODO: optimize call if it is known to be a fn
       :else               (emit-ifn-dispatch callable args ctx))}))

(defmacro in-global-env [& body]
  `(env/ensure *compiler-env*
     ~@body))

(defn eval-ast [ast]
  ;; (print ast)
  (let [jit  (jit/singleton)
        name (name (gensym "eval"))
        unit (emit/unit name)]
    (emit/with-unit unit
      (emit/define-fun! name emit/ValueP []
        (fn [f]
          (let [tag (emit/mangle-ns (:ns @*compiler-env*))]
            (->> (assoc (fun-context f) :tag tag)
                 (compile-ast ast)
                 (:value))))))
    (jit/register unit)
    (when-let [addr (jit/resolve-address name)]
      (invoke* addr :native []))))

(defn eval [form]
  (binding [trq/*resolver* nil
            trq/*eval*     eval-ast]
    (in-global-env
      (-> form trq/analyze eval-ast))))

(defn compile-ns [ns]
  (binding [trq/*resolver* (r/project-resolver (fs/cwd))
            trq/*eval*     eval-ast]
    (in-global-env (trq/load-ns ns))
    (when-let [ast (get-in @*compiler-env* [:namespaces ns])]
      ;; TODO: here we would trigger a second compiler pass
      ;; that optimizes the code and emits an object file
      ;; (compile-ast ast (empty-context))
      nil)))
