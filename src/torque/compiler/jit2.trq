;; -*- mode: clojure;-*-

(ns torque.compiler.jit2
  (:require
    [torque.compiler.emit :as emit]
    [torque.compiler.generators :as gen]
    [torque.compiler.runtime :as rt]
    [torque.compiler.util :as util]
    [torque.ffi :as ffi]
    [torque.string :as str]))

(def ^:private libjit (ffi/so "jit"))
(def ^:private libabi (ffi/so "abi"))

(ffi/defimport make-jit libjit init :ptr [])
(ffi/defimport add-ast libjit add_ast :void [:ptr :string :ptr])
(ffi/defimport add-module libjit add_module :void [:ptr :ptr])
(ffi/defimport lookup libjit lookup :ptr [:ptr :string])
(ffi/defimport lookup-value libjit lookup :native [:ptr :string])

(deftype JIT [handle]
  IPointerTarget
  (-intptr [_] handle))

(def jit (atom nil))

(defn singleton []
  (when (nil? @jit)
    (reset! jit (new JIT (make-jit)))
    (let [rt0 (rt/rt0)]
      (add-module @jit rt0)))
  @jit)

(defn register-unit [name unit]
  (add-module (intptr (singleton)) (intptr unit)))

(defn register-fun [name emitter]
  (add-ast (intptr (singleton)) name (ffi/fnptr emitter :ptr [])))

(defn ^:private -resolve
  [symbol resolve-fn]
  (if (named? symbol)
    (when-let [jit (singleton)]
      (ffi/not-null (resolve-fn (intptr jit) symbol)))
    ;; TODO: return error
    ))

(defn resolve-value
  "Resolve a name to a memory address"
  [symbol]
  (-resolve symbol lookup-value))

(defn resolve-address
  "Resolve a name to a memory address"
  [symbol]
  (-resolve symbol lookup))
