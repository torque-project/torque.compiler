;; -*- mode: clojure;-*-

(ns torque.compiler.generators
  (:require
    [torque.compiler.builtins :as builtin]
    [torque.compiler.emit :as emit]
    [torque.lang.debug :as d]))

(def max-field-length 256)

(defn ^:private load-extensions [type]
  (emit/get-field type emit/dispatch-entry emit/type-exts))

(defn ^:private load-extension [extensions id]
  (emit/deref extensions emit/dispatch-entry [id emit/one]))

(defn ^:private load-dispatch-table [protocol idx arity]
  (emit/deref protocol emit/arities-table [idx emit/zero arity]))

(defn ^:private emit-protocol-call [callable protocol meth arity args]
  (let [ptr (load-dispatch-table protocol meth arity)]
    (emit/call ptr (emit/fun-type emit/ValueP args) args)))

(defn ^:private emit-protocol-call* [callable id meth arity args]
  (emit-protocol-call callable
    (load-extension
      (load-extensions (emit/value-type callable))
      (emit/int emit/int32 id))
    (emit/int emit/int32 meth)
    (emit/int emit/int32 arity)
    (cons callable args)))

(defn find-protocol [type protocol]
  (let [extensions (load-extensions type)
        size       (emit/get-field type emit/int32 emit/type-num-exts)
        idx        (emit/mutable-local emit/zero "nexts")]
    (emit/in-block "dispatch"
      (fn [block]
        (emit/if* emit/methods
          (fn []
            (->> (emit/load emit/int32 idx "idx") (emit/cmp emit/gt size)))
          (fn []
            (emit/if* emit/methods
              (fn []
                (let [cur (emit/load emit/int32 idx "idx")
                      id  (emit/deref extensions [cur emit/zero])]
                  (emit/cmp emit/eq id protocol)))
              (fn []
                (load-extension extensions (emit/load emit/int32 idx "idx")))
              (fn []
                (emit/store idx (emit/add (emit/load emit/int32 idx "id") emit/one))
                (emit/recur* block))))
          (fn []
            emit/not-implemented))))))

(defn ^:private fixed-args [fun max-fixed-arity]
  (map (partial emit/fn-arg fun) (range max-fixed-arity)))

(defn ^:private mangle-forwarder [name arity max-fixed-arity]
  (str name "__rest_arg_forwarder_" arity "_" max-fixed-arity))

(defn ^:private variadic-forwarder [name arity impl max-fixed-arity]
  (let [return-type emit/ValueP
        arg-types   (vec (repeat (inc arity) emit/ValueP))
        t           (emit/fun-type return-type arg-types)]
    (emit/define-fun! (mangle-forwarder name arity max-fixed-arity)
      ;; {:link :once}
      return-type arg-types
      (fn [fun]
        ;; accumulate args and call rest arg arity
        (let [count (- arity max-fixed-arity)
              rargs (if (> count 0)
                      (builtin/make-array (emit/int count))
                      emit/nil*)]
          (when rargs
            (dotimes [n count]
              (let [idx (+ max-fixed-arity n)]
                (builtin/aset rargs (emit/int n) (emit/fn-arg fun idx)))))
          ; ;; call thru to actual implementation
          (->> (concat 
                 (fixed-args fun max-fixed-arity) 
                 [(builtin/make-indexed-seq rargs)])
               (cons (emit/arg fun 0))
               (emit/call impl t)))))))

(defn ^:private variadic-forwarders [name arities impl max-fixed-arity]
  (if (< max-fixed-arity 8)
    (let [start-arity max-fixed-arity]
      (reduce
       (fn [v arity]
         ;; implement a forwarder to the variadic implementation
         ;; only if there is no fixed arity implementation. this
         ;; correctly dispatches the case:
         ;; (fn ([x] ...) ([x & xs] ...))
         (if (= (get v arity) emit/nil*)
           (->> (-> (variadic-forwarder name arity impl max-fixed-arity)
                    (emit/value)
                    (emit/bitcast emit/int8-ptr))
                (assoc v arity))
           v))
        arities
        (take (- 8 start-arity) (iterate inc start-arity))))))

(defn ^:private protocol-meth [name arities]
  (->> (reduce
         (fn [v impl]
           (let [fun-ptr (emit/bitcast (:value impl) emit/int8-ptr)
                 arity   (:arity impl)]
             (if (:variadic? impl)
               (variadic-forwarders name v (:value impl) arity)
               (assoc v arity fun-ptr))))
         (vec (replicate 8 emit/nil*))
         arities)
       (emit/array emit/int8-ptr)
       (vector)
       (emit/struct emit/arities-table)))

(defn swizzle-cast [type val]
  (emit/bitcast val type))

(defn protocol [name id impls]
  (->> impls
       (mapv
         (fn [impl]
           (protocol-meth name impl)))
       (emit/array emit/arities-table)
       (emit/global (str name "_methods"))
       (swizzle-cast (emit/ptr-of emit/arities-table))
       (vector (emit/int emit/int32 id))
       (emit/struct emit/dispatch-entry)))

(defn protocol* [name id & impls]
  (let [x (protocol name id impls)]
    x))

(def strcmp-type (emit/fun-type emit/int32 [emit/int8-ptr emit/int8-ptr emit/int64]))

(defn import-strcmp []
  (emit/declare-fun! "strncmp" emit/int32
    [emit/int8-ptr emit/int8-ptr emit/int64]))

(defn compare-field [this str strcmp]
  (fn [field]
    (let [field-name (emit/global ".field" (emit/string (name (:name field))))]
      (->> [field-name str (emit/int max-field-length)]
           (emit/call strcmp strcmp-type)
           (emit/cmp emit/eq emit/zero)))))

(defn get-field [type this comparator]
  (fn [field]
    (fn []
      (emit/select
       (comparator field)
       (emit/box (emit/get-field type this (:type field) (inc (:field-id field))))
       emit/nil*))))

(defn field-getter [name type fields]
  (let [strcmp (import-strcmp)
        name   (str name "_get_field")]
    (emit/define-fun! name emit/ValueP
      [(emit/ptr-of type) emit/int8-ptr]
      (fn [fun]
        (let [this        (emit/arg fun 0)
              str         (emit/arg fun 1)
              getter      (get-field type this (compare-field this str strcmp))
              field-tests (mapv getter fields)]
          (emit/cond* emit/ValueP field-tests (fn [] emit/nil*)))))))

(defn set-field [t this field val]
  (fn []
    (emit/set-field t this (inc (:field-id field)) val)
    emit/nil*))

(defn field-setter [name type fields]
  (let [strcmp (import-strcmp)
        name   (str name "_set_field")]
    (emit/define-fun! name emit/ValueP
      [(emit/ptr-of type) emit/int8-ptr emit/ValueP]
      (fn [fun]
        (let [this       (emit/arg fun 0)
              str        (emit/arg fun 1)
              val        (emit/arg fun 2)
              comparator (compare-field this str strcmp)
              conditions (reduce
                           (fn [prev field]
                             (if (emit/value? (:type field emit/ValueP))
                               (fn []
                                 (emit/if*
                                   (fn [] (comparator field))
                                   (set-field type this field val)
                                   prev))
                               prev))
                           (fn [] emit/nil*)
                           fields)]
          (conditions))))))

(defn ctor [name type instance-struct field-types]
  (emit/define-fun! (str name "_new")
    emit/ValueP field-types
    (fn [fun]
      (let [ptr-type (emit/ptr-of instance-struct)
            mem      (emit/allocate (emit/sizeof instance-struct))
            instance (emit/bitcast mem ptr-type)]
        (emit/set-field instance-struct instance 0 type)
        (loop [n     0
               types field-types]
          (when-let [field-type (first types)]
            (emit/set-field instance-struct instance (inc n) (emit/arg fun n))
            (recur (inc n) (next types))))
        (emit/bitcast instance emit/ValueP)))))

(defn field-type [field]
  (:type field emit/ValueP))

(defn type [name fields protocol-fn]
  (let [field-types    (map field-type fields)
        instance-type  (emit/define-struct name
                         (vec (cons emit/TypeP field-types)))
        type           (emit/global (str name "_static") emit/ValueType nil)
        type-ref       (emit/global name emit/ValueP type)
        protocols      (protocol-fn instance-type)
        table-size     (emit/int emit/int32 (count protocols))
        entries        (emit/global (str name "_entries")
                         (emit/array emit/dispatch-entry protocols))
        protocol-table (emit/bitcast entries emit/dispatch-table)
        num-fields     (emit/int emit/int32 (count fields))
        field-getter   (field-getter name instance-type fields)
        field-setter   (field-setter name instance-type fields)]
    (emit/set-global! type
      (emit/struct emit/ValueType
                   [table-size
                    protocol-table
                    num-fields
                    (emit/bitcast field-getter emit/int8-ptr)
                    (emit/bitcast field-setter emit/int8-ptr)]))
    (ctor name type instance-type field-types)
    instance-type))
