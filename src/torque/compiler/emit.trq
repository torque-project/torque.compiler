;; -*- mode: clojure;-*-

(ns torque.compiler.emit
  (:require
    [torque.compiler.util :as util]
    [torque.ffi :as ffi]
    [torque.string :as str]))

(def ^:private llvm (ffi/so "LLVM"))

(ffi/defimport global-context llvm LLVMGetGlobalContext :ptr [])

;; optimizer API
(ffi/defimport pass-manager llvm LLVMCreateFunctionPassManagerForModule
  :ptr [:ptr])
(ffi/defimport init-passes llvm LLVMInitializeFunctionPassManager
  :uint32 [:ptr])

;; module API
(ffi/defimport module llvm LLVMModuleCreateWithName :ptr [:string])
(ffi/defimport dump llvm LLVMDumpModule :void [:ptr])
(ffi/defimport add-fun! llvm LLVMAddFunction :ptr [:ptr :string :ptr])
(ffi/defimport get-fun llvm LLVMGetNamedFunction :ptr [:ptr :string])
(ffi/defimport add-global-ifun! llvm LLVMAddGlobalIFunc :ptr [:ptr :string :uint32 :ptr :uint32 :ptr])
(ffi/defimport named-global llvm LLVMGetNamedGlobal :ptr [:ptr :string])
(ffi/defimport add-global! llvm LLVMAddGlobal :ptr [:ptr :ptr :string])
(ffi/defimport set-init! llvm LLVMSetInitializer :void [:ptr :ptr])

;; function API
(ffi/defimport add-block! llvm LLVMAppendBasicBlock :ptr [:ptr :string])
(ffi/defimport insert-block! llvm LLVMInsertBasicBlock :ptr [:ptr :string])
(ffi/defimport entry-block llvm LLVMGetEntryBasicBlock :ptr [:ptr :ptr :ptr])
(ffi/defimport get-arg llvm LLVMGetParam :ptr [:ptr :uint32])
(ffi/defimport set-linkage! llvm LLVMSetLinkage :void [:ptr :uint32])
(ffi/defimport -set-personality! llvm LLVMSetPersonalityFn :void [:ptr :ptr])
;; (ffi/defimport -add-attribute llvm LLVMAddFunctionAttr :void [:ptr :ptr])

;; builder API
(ffi/defimport -builder llvm LLVMCreateBuilder :ptr [])
(ffi/defimport builder-fun llvm LLVMGetBasicBlockParent :ptr [:ptr])
(ffi/defimport get-insert-block llvm LLVMGetInsertBlock :ptr [:ptr])
(ffi/defimport get-first-block llvm LLVMGetFirstBasicBlock :ptr [:ptr])
(ffi/defimport set-insert-block! llvm LLVMPositionBuilderAtEnd :ptr [:ptr :ptr])
(ffi/defimport dispose-builder llvm LLVMDisposeBuilder :void [:ptr])
(ffi/defimport -return  llvm LLVMBuildRet :ptr [:ptr :ptr])
(ffi/defimport -call llvm LLVMBuildCall :ptr [:ptr :ptr :ptr :uint32 :string])
(ffi/defimport -invoke llvm LLVMBuildInvoke :ptr [:ptr :ptr :ptr :uint32 :ptr :ptr :string])
(ffi/defimport -add llvm LLVMBuildAdd :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -sub llvm LLVMBuildSub :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -mul llvm LLVMBuildMul :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -div llvm LLVMBuildSDiv :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -bit-and llvm LLVMBuildAnd :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -bit-or llvm LLVMBuildOr :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -shl llvm LLVMBuildShl :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -lshr llvm LLVMBuildLShr :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -icmp llvm LLVMBuildICmp :ptr [:ptr :uint32 :ptr :ptr :string])
(ffi/defimport -not llvm LLVMBuildNot :ptr [:ptr :ptr :string])
(ffi/defimport br llvm LLVMBuildBr :void [:ptr :ptr])
(ffi/defimport cond-br llvm LLVMBuildCondBr :ptr [:ptr :ptr :ptr :ptr])
(ffi/defimport phi llvm LLVMBuildPhi :ptr [:ptr :ptr :string])
(ffi/defimport -select llvm LLVMBuildSelect :ptr [:ptr :ptr :ptr :ptr :string])
(ffi/defimport add-incoming! llvm LLVMAddIncoming :void [:ptr :ptr :ptr :uint32])
(ffi/defimport alloca llvm LLVMBuildAlloca :ptr [:ptr :ptr :string])
(ffi/defimport -store llvm LLVMBuildStore :ptr [:ptr :ptr :ptr])
(ffi/defimport -load llvm LLVMBuildLoad :ptr [:ptr :ptr :string])
(ffi/defimport -bitcast llvm LLVMBuildBitCast :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -trunc llvm LLVMBuildTrunc :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -ptrcast llvm LLVMBuildPointerCast :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -ptrtoint llvm LLVMBuildPtrToInt :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -cast llvm LLVMBuildCast :ptr [:ptr :ptr :ptr :string])
;; (ffi/defimport malloc llvm LLVMBuildMalloc :ptr [:ptr :ptr :string])
(ffi/defimport -gep llvm LLVMBuildGEP :ptr [:ptr :ptr :ptr :uint32 :string])
(ffi/defimport -igep llvm LLVMBuildInBoundsGEP :ptr [:ptr :ptr :ptr :uint32 :string])
(ffi/defimport struct-gep llvm LLVMBuildStructGEP :ptr [:ptr :ptr :uint32 :string])
(ffi/defimport -resume llvm LLVMBuildResume :ptr [:ptr :ptr])
(ffi/defimport -landingpad llvm LLVMBuildLandingPad :ptr [:ptr :ptr :ptr :uint32 :string])
(ffi/defimport -unreachable llvm LLVMBuildUnreachable :ptr [:ptr])
(ffi/defimport -add-catch llvm LLVMAddClause :ptr [:ptr :ptr])

;; meta data
(ffi/defimport -add-meta-data llvm LLVMAddNamedMetadataOperand :void [:ptr :string :ptr])
(ffi/defimport -md-node llvm LLVMMDNode :ptr [:ptr :uint32])
(ffi/defimport -md-string llvm LLVMMDString :ptr [:string :uint32])

;; utilities
(ffi/defimport -find-type llvm LLVMGetTypeByName :ptr [:ptr :string])
(ffi/defimport get-type llvm LLVMTypeOf :ptr [:ptr])
(ffi/defimport kind   llvm LLVMGetTypeKind :uint32 [:ptr])
(ffi/defimport integer-width llvm LLVMGetIntTypeWidth :uint32 [:ptr])

(ffi/defimport pr-module llvm LLVMPrintModuleToString :ptr [:ptr])
(ffi/defimport pr-type   llvm LLVMPrintTypeToString :ptr [:ptr])
(ffi/defimport pr-value  llvm LLVMPrintValueToString :ptr [:ptr])

;; constants
(ffi/defimport const-null llvm LLVMConstNull :ptr [:ptr])
(ffi/defimport const-int  llvm LLVMConstInt :ptr [:ptr :uint64 :bool])
(ffi/defimport const-array llvm LLVMConstArray :ptr [:ptr :ptr :uint32])
(ffi/defimport const-string llvm LLVMConstString :ptr [:string :uint32 :bool])
(ffi/defimport const-struct llvm LLVMConstStruct :ptr [:ptr :uint32 :bool])
(ffi/defimport const-typed llvm LLVMConstNamedStruct :ptr [:ptr :ptr :uint32])
(ffi/defimport const-cast llvm LLVMConstBitCast :ptr [:ptr :ptr])
(ffi/defimport const-trunc llvm LLVMConstTrunc :ptr [:ptr :ptr])
(ffi/defimport const-gep llvm LLVMConstInBoundsGEP :ptr [:ptr :ptr :uint32])
(ffi/defimport -sizeof llvm LLVMSizeOf :ptr [:ptr])

;; type constructors
(ffi/defimport named-type llvm LLVMStructCreateNamed :ptr [:ptr :string])
(ffi/defimport type-body llvm LLVMStructSetBody :void [:ptr :ptr :uint32 :bool])
(ffi/defimport anon-type llvm LLVMStructType :ptr [:ptr :uint32 :bool])
(ffi/defimport -fun-type llvm LLVMFunctionType :ptr [:ptr :ptr :uint32 :bool])
(ffi/defimport ptr-type llvm LLVMPointerType :ptr [:ptr :uint32])
(ffi/defimport arr-type llvm LLVMArrayType :ptr [:ptr :uint32])
(ffi/defimport void-type llvm LLVMVoidType :ptr [])
(ffi/defimport int1-type llvm LLVMInt1Type :ptr [])
(ffi/defimport int8-type llvm LLVMInt8Type :ptr [])
(ffi/defimport int16-type llvm LLVMInt16Type :ptr [])
(ffi/defimport int32-type llvm LLVMInt32Type :ptr [])
(ffi/defimport int64-type llvm LLVMInt64Type :ptr [])

(def int-kind 8)
(def ptr-kind 12)

(def eq 32)
(def ne 33)
(def gt 38)
(def ge 39)
(def lt 40)
(def le 41)

(defprotocol ITyped
  (-typeof [_]))

(def ^:dynamic *unit*
  "The currently emitted compilation unit"
  nil)

(def ^:dynamic *builder*
  "The builder object for the currently emitted function"
  nil)

(def ^:dynamic *catch*
  "A catch block for the current scope. When this is bound, calls
  to functions will use this block as the target for exceptions"
  nil)

(deftype Unit [handle pass-manager]

  IPrintable
  (-str [_]
    (if (ffi/not-null handle)
      (util/message (pr-module handle))
      "<unit: null>"))

  IPointerTarget
  (-intptr [_] handle))

(defn unit [n]
  (let [m  (module n)
        pm (pass-manager m)]
    (new Unit m pm)))

(defn unit? [x]
  (instance? Unit x))

(defn optimizer-passes [x]
  (. x pass-manager))

(defmacro with-unit [unit & forms]
  `(binding [*unit* ~unit]
     ~@forms
     *unit*))

(deftype Type [handle]
  IPrintable
  (-str [_]
    (util/message (pr-type handle)))

  IPointerTarget
  (-intptr [_] handle)

  IEquiv
  (-equiv [_ other]
    (== handle (. other handle)))

  ITyped
  (-typeof [this] this))

(defn type [x]
  (if (instance? Type x)
    x
    (new Type x)))

(deftype Value [handle terminator?]
  IPrintable
  (-str [_]
    (if (ffi/not-null handle)
      (util/message (pr-value handle))
      "<value: null>"))

  IPointerTarget
  (-intptr [_] handle)

  ITyped
  (-typeof [_] (type (get-type handle))))

(defn value [handle]
  (new Value handle false))

(defn terminator [handle]
  (new Value handle true))

(defn value? [x]
  (instance? Value x))

(defn terminator? [x]
  (and (value? x) (. x terminator?)))

(deftype Builder [handle]
  IResource
  (-dispose [_]
    (dispose-builder handle))
  IPointerTarget
  (-intptr [_] handle))

(defn builder
  ([]
   (new Builder (-builder)))
  ([block]
   (let [b (builder)]
     (set-insert-block! (intptr b) (intptr block))
     b)))

(defmacro with-builder [b & forms]
  `(with-resource [b# ~b]
     (binding [*builder* b#]
       ~@forms
       nil)))

(defn ^:private current-fun []
  (builder-fun (get-insert-block (intptr *builder*))))

(defn in-block [name block-fn]
  (let [fun   (current-fun)
        block (add-block! fun name)]
    (br (intptr *builder*) block)
    (set-insert-block! (intptr *builder*) block)
    (block-fn block)))

(defmacro with-block [block & forms]
  `(let [tmp# (get-insert-block (intptr *builder*))]
     (set-insert-block! *builder* ~block)
     (let [ret# (do ~@forms)]
       (set-insert-block! (intptr *builder*) tmp#)
       ret#)))

(defn type-of [x]
  (-typeof x))

(defn ptr-of [x]
  (type (ptr-type (intptr (type-of x)) 0)))

;; predefined types
(def void  (type (void-type)))
(def int1  (type (int1-type)))
(def int8  (type (int8-type)))
(def int16 (type (int16-type)))
(def int32 (type (int32-type)))
(def int64 (type (int64-type)))

(def void-ptr (ptr-of void))
(def int8-ptr (ptr-of int8))
(def int8-ptr-ptr (ptr-of int8-ptr))

(defn array-type [t n]
  (type (arr-type (intptr t) n)))

(defn declare-struct [n]
  (type (named-type (global-context) n)))

(defn define-struct [t field-types]
  (let [t    (if (string? t) (declare-struct t) t)
        ptrs (util/ptrs-to-mem field-types)]
    (type-body (intptr t) ptrs (count field-types) false)
    t))

(defn fun-type
  ([ret args]
   (fun-type ret args false))
  ([ret args var]
   (type
     (-fun-type
       (intptr ret)
       (util/ptrs-to-mem (mapv type-of args))
       (count args)
       var))))

;; basic runtime type definitions
(def arities-table
  "A fixed size table of function, where each function represents
   a call arity in a protocol method."
  (define-struct "Method" [(array-type int8-ptr 8)]))

(def methods
  (ptr-of arities-table))

(def dispatch-entry
  "A table of methods implemented by a single protocol, indexed by a
   method id"
  (define-struct "DispatchEntry" [int32 methods]))

(def dispatch-table
  "A pointer to a protocol dispatch table"
  (ptr-of dispatch-entry))

(def ValueType (declare-struct "ValueType"))
(def TypeP     (ptr-of ValueType))
(def Value     (define-struct "Value" [TypeP]))
(def ValueP    (ptr-of Value))
(def Protocol  (define-struct "Protocol" [TypeP int32]))
(def ProtoP    (ptr-of Protocol))

(define-struct ValueType
  [int32
   dispatch-table
   int32
   (ptr-of (fun-type ValueP [ValueP int8-ptr]))
   (ptr-of (fun-type ValueP [ValueP int8-ptr ValueP]))])

(def type-num-exts   0)
(def type-exts       1)
(def type-num-fields 2)
(def type-get-field  3)
(def type-set-field  4)

;; constant runtime values
(def nil* (value (const-null (intptr ValueP))))
(def zero (value (const-int (intptr int32) 0 false)))
(def one  (value (const-int (intptr int32) 1 false)))

(def pointer-size (value (const-int (intptr int64) 8 false)))

(defn null [t]
  (value (const-null (intptr t))))

(def not-implemented
  (null methods))

(defn bool [x]
  (if (boolean? x)
    (value
      (if x
        (const-int (intptr int1) 1 false)
        (const-int (intptr int1) 0 false)))
    ;; TODO: error
    ))

(defn int
  ([x]
   (int int64 x))
  ([t x]
   (if (integer? x)
     (value (const-int (intptr t) x true))
     ;; TODO: error
     )))

(defn int? [x]
  (== (kind (intptr (type-of x))) int-kind))

(defn find-type [name]
  (type (-find-type (intptr *unit*) name)))

(defn find-global [name]
  (when-let [g (ffi/not-null (named-global (intptr *unit*) name))]
    (value g)))

(defn extern [name type]
  (or (find-global name)
      (value (add-global! (intptr *unit*) (intptr type) name))))

(defn mutable-local [val name]
  (let [local (alloca (intptr *builder*) (intptr (type-of val)) name)]
    (-store (intptr *builder*) (intptr val) local)
    (value local)))

(defn store [mutable val]
  (value (-store (intptr *builder*) (intptr val) (intptr mutable))))

(defn load [mutable name]
  (value (-load (intptr *builder*) (intptr mutable) name)))

(defn get-field [x idx]
  (load (struct-gep (intptr *builder*) (intptr x) idx "") ""))

(defn set-field [inst n val]
  (store (struct-gep (intptr *builder*) (intptr inst) n "") val))

(defn value? [val]
  (== (intptr (type-of val)) (intptr ValueP)))

(defn value-type [val]
  (get-field val 0))

(defn true* []
  (load (extern "torque_lang_True" ValueP) ""))

(defn false* []
  (load (extern "torque_lang_False" ValueP) ""))

(defn bitcast
  ([val type]
    (if *builder*
      (value (-bitcast (intptr *builder*) (intptr val) (intptr type) ""))
      (value (const-cast (intptr val) (intptr type))))))

(defn ptrcast [val type]
  (value (-ptrcast (intptr *builder*) (intptr val) (intptr type) "")))

(defn trunc
  ([val type]
   (value (const-trunc (intptr val) (intptr type))))
  ([val type]
   (value (-trunc (intptr *builder*) (intptr val) (intptr type) ""))))

(defn mangle-ns [ns]
  (str/replace (name ns) "." "_"))

(defn mangle-var [var]
  (str (mangle-ns (:ns var)) "_" (:name var)))

(defn mangle [name fn]
  (if (:variadic? fn)
    (str name "_variadic")
    (str name "_" (:fixed-arity fn))))

(defn mangle-method [type protocol meth arity]
  (str type "_" protocol "_" meth "_" arity))

(defn find-fun [name]
  (get-fun (intptr *unit*) name))

(defn declare-fun!
 ([name ret args]
  (declare-fun! name ret args false))
 ([name ret args var]
  (let [type (fun-type (type ret) (map type args) var)]
    (value
      (or (ffi/not-null (get-fun (intptr *unit*) name))
          (add-fun! (intptr *unit*) name (intptr type)))))))

(defn declare-ifun!
 ([name ret args]
  (declare-ifun! name ret args false))
 ([name ret args var]
  (let [type (fun-type (type ret) (map type args) var)]
    (value 
      (or (ffi/not-null (get-fun (intptr *unit*) name))
          (add-fun! (intptr *unit*) name (intptr type)))))))

(defn declare-ctor! [name fields]
  (declare-fun! (str name "_new") ValueP (cons int8-ptr fields)))

(defn fun-from-args [ptr ret args]
  (->> (fun-type ret args)
       (type)
       (ptr-of)
       (bitcast ptr)))

(defn invoke
  ([fun args catch-block]
   (let [cont-block (add-block! (intptr (current-fun)) "")
         ret        (invoke fun args cont-block catch-block)]
     (set-insert-block! (intptr *builder*) (intptr cont-block))
     ret))
  ([fun args cont-block catch-block]
   (terminator
    (-invoke (intptr *builder*)
             (intptr fun)
             (util/ptrs-to-mem args)
             (count args)
             (intptr cont-block) (intptr catch-block)
             ""))))

(defn call [fun args]
  (if *catch*
    (invoke fun args #_(:cont *catch*) (:unwind *catch*))
    (value
      (-call (intptr *builder*)
             (intptr fun)
             (util/ptrs-to-mem args)
             (count args)
             ""))))

(defn resume [ex]
  (-resume (intptr *builder*) (intptr ex)))

(defn deref [val indices]
  (load (-igep (intptr *builder*)
               (intptr val)
               (util/ptrs-to-mem indices)
               (count indices)
               "")
        ""))

(defn advance-ptr [ptr off]
  (-gep (intptr *builder*)
        (intptr ptr)
        (util/ptrs-to-mem [off])
        1
        ""))

(defn buffer-at [buffer idx]
  (load (advance-ptr buffer idx) ""))

(def box-type
  (type (anon-type (util/ptrs-to-mem [int8-ptr int8-ptr int64]) 3 false)))

(def box-ptr
  (ptr-of box-type))

(defn boxed? [a]
  (and (not (int? a))
       (let [type (extern "torque_lang_Integer" TypeP)]
         (value
          (-icmp (intptr *builder*)
                 eq
                 (intptr (load type ""))
                 (intptr (value-type a))
                 "")))))

(defn unbox [x]
  (if (= (-> x type-of intptr kind) int-kind)
    x
    (let [box (bitcast x box-ptr)
          ptr (struct-gep (intptr *builder*) (intptr box) 2 "")]
      (value (-load (intptr *builder*) ptr "")))))

(defn sizeof [t]
  (value (-sizeof (intptr t))))

(defn malloc [size]
  (-> (declare-fun! "_malloc" int8-ptr [int64])
      (call [size])))

(defn allocate [size]
  (malloc size))

(defn onstack [type size]
  (alloca (intptr *builder*) (intptr type) (intptr size)))

(defn memcpy [dst src len]
  (-> (declare-fun! "_memcpy" int8-ptr [int8-ptr int8-ptr int64])
      (call [dst src len])))

(defn memcmp [dst src len]
  (-> (declare-fun! "_memcmp" int64 [int8-ptr int8-ptr int64])
      (call [dst src len])))

(defn strlen [s]
  (-> (declare-fun! "_strlen" int64 [int8-ptr])
      (call [s])))

(defn new* [name args]
  (let [num    (count args)
        types  (mapv (fn [x] (type-of x)) args)
        values (mapv (fn [x] (intptr x)) args)
        ctor   (declare-fun! (str name "_new") (intptr ValueP) types)]
     (-> (intptr *builder*)
         (-call (intptr ctor) (util/ptrs-to-mem values) num "")
         (value))))

(defn ^:private force-box [x]
  (-> (declare-fun! "torque_lang_Integer_new" ValueP [int64])
      (call [(-ptrtoint (intptr *builder*) (intptr x) (intptr int64) "")])))

(defn ^:private select-boolean [x]
  (value
    (-select (intptr *builder*)
             (intptr x)
             (intptr (true*))
             (intptr (false*))
             "")))

(defn box [x]
  (when x
    (let [type (type-of x)]
      (if (= (-> type intptr kind) int-kind)
        (let [width (integer-width (intptr type))]
          (if (== width 1)
            (select-boolean x)
            (force-box x)))
        x))))

(defn return [val]
  (value (-return (intptr *builder*) (intptr (box val)))))

(defn ^:private linkage-flag [linkage]
  (cond
    (= linkage :once) 3
    :else
    (throw (ex-info (str "Unsupported linkage type: " linkage) {}))))

(defn define-fun!
  ([name ret args body-fn]
   (define-fun! name {}  ret args body-fn))
  ([name opts ret args body-fn]
   (let [fun (declare-fun! name ret args)]
     (when (:unwind opts)
       ;; ()
       ;; (-add-attribute (intptr fun) (bit-shift-left 1 30))
     )
     (when-let [linkage (:link opts)]
       (set-linkage! (intptr fun) (linkage-flag linkage)))
     (when (ffi/not-null (get-first-block (intptr fun)))
       (throw (ex-info (str "Function " name " is already defined") {})))
     (with-builder (builder (value (add-block! (intptr fun) "entry")))
       (return (body-fn fun)))
     fun)))

(defn arg [fun n]
  (value (get-arg (intptr fun) n)))

(defn fn-arg [fun n]
  (arg fun (inc n)))

(defn add [a b]
  (value (-add (intptr *builder*)
               (intptr (unbox a))
               (intptr (unbox b))
               "")))

(defn sub [a b]
  (value (-sub (intptr *builder*)
               (intptr (unbox a))
               (intptr (unbox b))
               "")))

(defn mul [a b]
  (value (-mul (intptr *builder*)
               (intptr (unbox a))
               (intptr (unbox b))
               "")))

(defn div [a b]
  (value (-div (intptr *builder*)
               (intptr (unbox a))
               (intptr (unbox b))
               "")))

(defn bit-and [a b]
  (value (-bit-and (intptr *builder*)
                   (intptr (unbox a))
                   (intptr (unbox b))
                   "")))

(defn bit-or [a b]
  (value (-bit-or (intptr *builder*)
                  (intptr (unbox a))
                  (intptr (unbox b))
                  "")))

(defn bsl [a b]
  (value (-shl (intptr *builder*)
               (intptr (unbox a))
               (intptr (unbox b))
               "")))

(defn bsr [a b]
  (value (-lshr (intptr *builder*)
                (intptr (unbox a))
                (intptr (unbox b))
                "")))

(defn not* [a]
  (value (-not (intptr *builder*) (intptr a) "")))

(defn cmp [op a b]
  (value (-icmp (intptr *builder*) op (intptr a) (intptr b) "")))

(defn ^:private not-nil? [x]
  (value (-icmp (intptr *builder*) ne (intptr nil*) (intptr x) "")))

(defn ^:private truthy [x]
  (if (= (kind (intptr (type-of x))) ptr-kind)
    (bit-and (value
              (-icmp (intptr *builder*)
                     ne
                     (intptr x)
                     (intptr (false*))
                     ""))
            (not-nil? x))
    x))

(defn ^:private branch [block cont branch-fn]
  (set-insert-block! (intptr *builder*) block)
  (when-let [x (box (branch-fn))]
    (when-not (terminator? x)
      (br (intptr *builder*) cont))
    x))

(defn ^:private cont [type block values blocks]
  (set-insert-block! (intptr *builder*) block)
  (let [phi-value (phi (intptr *builder*) (intptr type) "")]
    (loop [blocks blocks
           values values]
      (let [block (first blocks)
            value (first values)]
        (when block
          (when value
            (add-incoming! phi-value
              (util/ptrs-to-mem [(intptr value)])
              (util/ptrs-to-mem [block])
              1))
          (recur (next blocks) (next values)))))
    (value phi-value)))

(defn if*
  ([test-fn then-fn else-fn]
   (if* ValueP test-fn then-fn else-fn))
  ([type test-fn then-fn else-fn]
   (let [fun        (current-fun)
         test       (truthy (test-fn))
         then-block (add-block! fun "then")
         else-block (add-block! fun "else")
         cont-block (add-block! fun "cont")
         test       (cond-br (intptr *builder*)
                             (intptr test)
                             then-block
                             else-block)
         then-value (branch then-block cont-block then-fn)
         ;; then block might have changed, due to a nested if
         then-block (get-insert-block (intptr *builder*))
         else-value (branch else-block cont-block else-fn)
         ;; else block might have changed, due to a nested if
         else-block (get-insert-block (intptr *builder*))]
     (cont type cont-block
           [then-value else-value]
           [then-block else-block]))))

(defn recur* [point]
  (br (intptr *builder*) point)
  nil)

(defn cond*
  ([type fs]
   (cond* type fs nil))
  ([type fs default]
   (let [fun    (current-fun)
         intro  (get-insert-block (intptr *builder*))
         out    (add-block! fun "")
         blocks (cons intro
                      (repeatedly (dec (count fs))
                                  (fn [] (insert-block! out ""))))
         fs     (if default (concat fs [default]) fs)
         values (mapv
                 (fn [f blocks]
                   (set-insert-block! (intptr *builder*) (first blocks))
                   (let [v (f)]
                     (if (== out (second blocks))
                       (br (intptr *builder*) out)
                       (cond-br (intptr *builder*)
                                (intptr (truthy v))
                                out
                                (second blocks)))
                     v))
                 fs (partition 2 1 [out] blocks))]
     (cont type out values blocks))))

(defn short-or
  "Builds a short circuit logical and construct out of a list of
   builder functions"
  [& fs]
  (cond* int1 fs))

(defn short-and
  [& fs]
  (cond* int1
    (concat
     (map
      (fn [f]
        (fn []
          (not* (f))))
      (butlast fs))
     [(last fs)])))

(defn select [cond a b]
  (value (-select (intptr *builder*) (intptr cond) (intptr a) (intptr b) "")))

(defn unreachable []
  (-unreachable (intptr *builder*)))

(defn personality []
  (declare-fun! "___trq_personality_v0" void [int32 int32 void-ptr void-ptr]))

(defn landingpad []
  (let [p   (personality)
        pad (-landingpad (intptr *builder*) (intptr ValueP) (intptr p) 1 "")] 
    (-add-catch (intptr pad) (intptr (null TypeP)))))

(defn catch-block [fun name]
  (let [block (add-block! (intptr fun) name)
        _     (set-insert-block! (intptr *builder*) block)
        pad   (landingpad)]
    block))

(defn try-catch [fun try-fn catch-fn]
  (let [out        (alloca (intptr *builder*) (intptr ValueP) "try.out")
        try-entry  (add-block! (intptr fun) "try")
        cont-block (add-block! (intptr fun) "try.cont")
        _          (br (intptr *builder*) (intptr try-entry))
        catch      (catch-block fun "try.catch")
        _          (branch try-entry cont-block (fn [] (try-fn cont-block catch out)))
        _          (branch catch cont-block (fn [] (catch-fn cont-block catch out)))]
    (set-insert-block! (intptr *builder*) cont-block)
    (load out "try.ret")))

(defn ^:private value-identical [a b]
  (if*
   (fn []
     (bit-and (not-nil? a) (not-nil? b)))
   (fn []
     (if*
      (fn []
        (short-or (partial boxed? a) (partial boxed? b)))
      (fn []
        (cmp eq (unbox a) (unbox b)))
      (fn []
        (cmp eq a b))))
   (fn []
     (cmp eq a b))))

(defn identical [a b]
  (if (= (type-of a) (type-of b))
    (let [k (kind (intptr (type-of a)))]
      (cond
        (== k int-kind) (cmp eq a b)
        (== k ptr-kind) (value-identical a b)
        :else (int int1 0)))
    (identical (box a) (box b))))

(defn import-type [name]
  (load (extern name TypeP) ""))

(defn instance-of [type x]
  (cmp eq type (value-type x)))

(defn set-global! [global init]
  (set-init! (intptr global) (if init (intptr init) (intptr nil*)))
  global)

(defn global
  ([name init]
   (global name (type-of init) init))
  ([name type init]
   (let [g (add-global! (intptr *unit*) (intptr type) name)]
     (set-init! g (if init (intptr init) (intptr nil*)))
     (value g))))

(defn putc [ch]
  (call (declare-fun! "putchar" int32 [int32]) [(int int32 ch)]))

(defn log [s x]
  (let [s (global ".print" (value (const-string s (count s) false)))]
    (call (declare-fun! "printf" int32 [int8-ptr] true) [s x])
    x))

(defn print [x]
  (log "PRINT: %d\n" (unbox x))
  nil*)

(defn string [init]
  (value (const-string init (count init) false)))

(defn array [type vals]
  (let [ptrs (util/ptrs-to-mem vals)]
    (value (const-array (intptr type) ptrs (count vals)))))

(defn struct
  ([fields]
   (value (const-struct (util/ptrs-to-mem fields) (count fields) false)))
  ([t fields]
   (value (const-typed (intptr t) (util/ptrs-to-mem fields) (count fields)))))

(defn md-node [children]
  (-md-node (util/ptrs-to-mem children) (count children)))

(defn md-string [s]
  (-md-string s (count s)))

(defn ^:private build-meta-data
  [md]
  (cond
    (vector? md) (md-node (mapv build-meta-data md))
    (string? md) (md-string md)))

(defn add-meta-data
  "Adds meta data to the current module. md is given as vector of vectors
   and strings"
  [md]
  (-add-meta-data (intptr *unit*) "" (build-meta-data md)))

(defn set-personality! [f]
  (-set-personality! (intptr f) (intptr (personality))))
