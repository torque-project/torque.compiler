;; -*- mode: clojure;-*-

(ns torque.compiler.emit
  (:require
    [torque.compiler.util :as util]
    [torque.ffi :as ffi]))

(def ^:private llvm (ffi/so "LLVM"))

(ffi/defimport global-context llvm LLVMGetGlobalContext :ptr [])

;; optimizer API
(ffi/defimport pass-manager llvm LLVMCreateFunctionPassManagerForModule
  :ptr [:ptr])
(ffi/defimport init-passes llvm LLVMInitializeFunctionPassManager
  :uint32 [:ptr])

;; module API
(ffi/defimport module llvm LLVMModuleCreateWithName :ptr [:string])
(ffi/defimport dump llvm LLVMDumpModule :void [:ptr])
(ffi/defimport add-fun! llvm LLVMAddFunction :ptr [:ptr :string :ptr])
(ffi/defimport get-fun llvm LLVMGetNamedFunction :ptr [:ptr :string])
(ffi/defimport named-global llvm LLVMGetNamedGlobal :ptr [:ptr :string])
(ffi/defimport add-global! llvm LLVMAddGlobal :ptr [:ptr :ptr :string])
(ffi/defimport set-init! llvm LLVMSetInitializer :void [:ptr :ptr])

;; function API
(ffi/defimport add-block! llvm LLVMAppendBasicBlock :ptr [:ptr :string])
(ffi/defimport insert-block! llvm LLVMInsertBasicBlock :ptr [:ptr :string])
(ffi/defimport get-arg llvm LLVMGetParam :ptr [:ptr :uint32])

;; builder API
(ffi/defimport -builder llvm LLVMCreateBuilder :ptr [])
(ffi/defimport builder-fun llvm LLVMGetBasicBlockParent :ptr [:ptr])
(ffi/defimport get-insert-block llvm LLVMGetInsertBlock :ptr [:ptr])
(ffi/defimport set-insert-block! llvm LLVMPositionBuilderAtEnd :ptr [:ptr :ptr])
(ffi/defimport dispose-builder llvm LLVMDisposeBuilder :void [:ptr])
(ffi/defimport -return  llvm LLVMBuildRet :ptr [:ptr :ptr])
(ffi/defimport -call llvm LLVMBuildCall :ptr [:ptr :ptr :ptr :uint32 :string])
(ffi/defimport -add llvm LLVMBuildAdd :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -sub llvm LLVMBuildSub :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -mul llvm LLVMBuildMul :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -div llvm LLVMBuildSDiv :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -bit-and llvm LLVMBuildAnd :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -bit-or llvm LLVMBuildOr :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -shl llvm LLVMBuildShl :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -lshr llvm LLVMBuildLShr :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -icmp llvm LLVMBuildICmp :ptr [:ptr :uint32 :ptr :ptr :string])
(ffi/defimport br llvm LLVMBuildBr :void [:ptr :ptr])
(ffi/defimport cond-br llvm LLVMBuildCondBr :ptr [:ptr :ptr :ptr :ptr])
(ffi/defimport phi llvm LLVMBuildPhi :ptr [:ptr :ptr :string])
(ffi/defimport add-incoming! llvm LLVMAddIncoming :void [:ptr :ptr :ptr :uint32])
(ffi/defimport alloca llvm LLVMBuildAlloca :ptr [:ptr :ptr :string])
(ffi/defimport -store llvm LLVMBuildStore :ptr [:ptr :ptr :ptr])
(ffi/defimport -load llvm LLVMBuildLoad :ptr [:ptr :ptr :string])
(ffi/defimport -bitcast llvm LLVMBuildBitCast :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -ptrcast llvm LLVMBuildPointerCast :ptr [:ptr :ptr :ptr :string])
(ffi/defimport -cast llvm LLVMBuildCast :ptr [:ptr :ptr :ptr :string])
(ffi/defimport malloc llvm LLVMBuildMalloc :ptr [:ptr :ptr :string])
(ffi/defimport gep llvm LLVMBuildGEP :ptr [:ptr :ptr :ptr :uint32 :string])
(ffi/defimport igep llvm LLVMBuildInBoundsGEP :ptr [:ptr :ptr :ptr :uint32 :string])
(ffi/defimport struct-gep llvm LLVMBuildStructGEP :ptr [:ptr :ptr :uint32 :string])

;; utilities
(ffi/defimport get-type llvm LLVMTypeOf :ptr [:ptr])
(ffi/defimport kind   llvm LLVMGetTypeKind :uint32 [:ptr])

(ffi/defimport pr-module llvm LLVMPrintModuleToString :ptr [:ptr])
(ffi/defimport pr-type   llvm LLVMPrintTypeToString :ptr [:ptr])
(ffi/defimport pr-value  llvm LLVMPrintValueToString :ptr [:ptr])

;; constants
(ffi/defimport const-null llvm LLVMConstNull :ptr [:ptr])
(ffi/defimport const-int  llvm LLVMConstInt :ptr [:ptr :uint64 :bool])
(ffi/defimport const-array llvm LLVMConstArray :ptr [:ptr :ptr :uint32])
(ffi/defimport const-string llvm LLVMConstString :ptr [:string :uint32 :bool])
(ffi/defimport const-struct llvm LLVMConstStruct :ptr [:ptr :uint32 :bool])
(ffi/defimport const-typed llvm LLVMConstNamedStruct :ptr [:ptr :ptr :uint32])
(ffi/defimport const-cast llvm LLVMConstBitCast :ptr [:ptr :ptr])
(ffi/defimport const-gep llvm LLVMConstInBoundsGEP :ptr [:ptr :ptr :uint32])

;; type constructors
(ffi/defimport named-type llvm LLVMStructCreateNamed :ptr [:ptr :string])
(ffi/defimport type-body llvm LLVMStructSetBody :void [:ptr :ptr :uint32 :bool])
(ffi/defimport anon-type llvm LLVMStructType :ptr [:ptr :uint32 :bool])
(ffi/defimport fun-type llvm LLVMFunctionType :ptr [:ptr :ptr :uint32 :bool])
(ffi/defimport ptr-type llvm LLVMPointerType :ptr [:ptr :uint32])
(ffi/defimport arr-type llvm LLVMArrayType :ptr [:ptr :uint32])
(ffi/defimport void-type llvm LLVMVoidType :ptr [])
(ffi/defimport int1-type llvm LLVMInt1Type :ptr [])
(ffi/defimport int8-type llvm LLVMInt8Type :ptr [])
(ffi/defimport int16-type llvm LLVMInt16Type :ptr [])
(ffi/defimport int32-type llvm LLVMInt32Type :ptr [])
(ffi/defimport int64-type llvm LLVMInt64Type :ptr [])

;; predefined types
(def void  (void-type))
(def int1  (int1-type))
(def int8  (int8-type))
(def int16 (int16-type))
(def int32 (int32-type))
(def int64 (int64-type))

(def int8-ptr (ptr-type int8 0))
(def int8-ptr-ptr (ptr-type int8-ptr 0))

(def int-kind 8)
(def ptr-kind 12)

(def eq 32)
(def ne 33)
(def gt 38)
(def ge 39)
(def lt 40)
(def le 41)

(defprotocol ITyped
  (-typeof [_]))

(def ^:dynamic *unit*
  "The currently emitted compilation unit"
  nil)

(def ^:dynamic *builder*
  "The builder object for the currently emitted function"
  nil)

(deftype Unit [handle pass-manager]

  IPrintable
  (-str [_]
    (if (ffi/not-null handle)
      (util/message (pr-module handle))
      "<unit: null>"))

  IPointerTarget
  (-intptr [_] handle))

(defn unit [n]
  (let [m (module n)]
    (new Unit m (pass-manager m))))

(defn unit? [x]
  (instance? Unit x))

(defn optimizer-passes [x]
  (. x pass-manager))

(defmacro with-unit [unit & forms]
  `(binding [*unit* ~unit]
     ~@forms
     *unit*))

(deftype Type [handle]
  IPrintable
  (-str [_]
    (util/message (pr-type handle)))

  IPointerTarget
  (-intptr [_] handle)

  IEquiv
  (-equiv [_ other]
    (== handle (. other handle)))

  ITyped
  (-typeof [this] this))

(defn type [x]
  (new Type x))

(deftype Value [handle]
  IPrintable
  (-str [_]
    (if (ffi/not-null handle)
      (util/message (pr-value handle))
      "<value: null>"))

  IPointerTarget
  (-intptr [_] handle)

  ITyped
  (-typeof [_] (type (get-type handle))))

(defn value [handle]
  (new Value handle))

(defn value? [x]
  (instance? Value x))

(deftype Builder [handle]
  IResource
  (-dispose [_]
    (dispose-builder handle))
  IPointerTarget
  (-intptr [_] handle))

(defn builder
  ([]
   (new Builder (-builder)))
  ([block]
   (let [b (builder)]
     (set-insert-block! (intptr b) (intptr block))
     b)))

(defmacro with-builder [b & forms]
  `(with-resource [b# ~b]
     (binding [*builder* b#]
       ~@forms
       nil)))

(defn ^:private current-fun []
  (builder-fun (get-insert-block (intptr *builder*))))

(defn in-block [name block-fn]
  (let [fun   (current-fun)
        block (add-block! fun name)]
    (br (intptr *builder*) block)
    (set-insert-block! (intptr *builder*) block)
    (block-fn block)))

(defmacro with-block [block & forms]
  `(let [tmp# (get-insert-block (intptr *builder*))]
     (set-insert-block! *builder* ~block)
     (let [ret# (do ~@forms)]
       (set-insert-block! (intptr *builder*) tmp#)
       ret#)))

(defn type-of [x]
  (-typeof x))

(defn ptr-of [x]
  (type (ptr-type (intptr (type-of x)) 0)))

(defn array-type [t n]
  (type (arr-type (intptr t) n)))

(defn define-struct [name field-types]
  (let [t    (named-type (global-context) name)
        ptrs (util/ptrs-to-mem field-types)]
    (type-body t ptrs (count field-types) false)
    (type t)))

;; basic runtime type definitions
(def arities-table
  "A fixed size table of function, where each function represents
   a call arity in a protocol method."
  (define-struct "Method" [(array-type int8-ptr 8)]))

(def methods
  (ptr-of arities-table))

(def dispatch-entry
  "A table of methods implemented by a single protocol, indexed by a
   method id"
  (define-struct "DispatchEntry" [int32 methods]))

(def dispatch-table
  "A pointer to a protocol dispatch table"
  (ptr-of dispatch-entry))

(def ValueType (define-struct "ValueType" [int32 dispatch-table]))
(def TypeP     (ptr-of ValueType))
(def Value     (define-struct "Value" [TypeP]))
(def ValueP    (ptr-of Value))
(def Protocol  (define-struct "Protocol" [int32]))
(def ProtoP    (ptr-of Protocol))

;; constant runtime values
(def nil* (value (const-null (intptr ValueP))))
(def zero (value (const-int int32 0 false)))
(def one  (value (const-int int32 1 false)))

(defn null [t]
  (value (const-null (intptr t))))

(def not-implemented
  (null methods))

(defn bool [x]
  (if (boolean? x)
    (value
      (if x
        (const-int int1 1 false)
        (const-int int1 0 false)))
    ;; TODO: error
    ))

(defn int
  ([x]
   (int int64 x))
  ([t x]
   (if (integer? x)
     (value (const-int t x true))
     ;; TODO: error
     )))

(defn extern [name type]
  (value (add-global! (intptr *unit*) (intptr type) name)))

(defn mutable-local [val name]
  (let [local (alloca (intptr *builder*) (intptr (type-of val)) name)]
    (-store (intptr *builder*) (intptr val) local)
    (value local)))

(defn store [mutable val]
  (value (-store (intptr *builder*) (intptr val) (intptr mutable))))

(defn load [mutable name]
  (value (-load (intptr *builder*) (intptr mutable) name)))

(defn get-field [x idx]
  (load (struct-gep (intptr *builder*) (intptr x) idx "") ""))

(defn set-field [inst n val]
  (store (struct-gep (intptr *builder*) (intptr inst) n "") val))

(defn value-type [val]
  (get-field val 0))

(defn bitcast
  ([val type]
   (value (const-cast (intptr val) (intptr type))))
  ([val type]
   (value (-bitcast (intptr *builder*) (intptr val) (intptr type) ""))))

(defn mangle [name fn]
  (if (:variadic? fn)
    (str name "_variadic")
    (str name "_" (:fixed-arity fn))))

(defn declare-fun! 
 ([name ret args]
  (declare-fun! name ret args false))
 ([name ret args var]
  (let [ptrs (util/ptrs-to-mem args)
        type (fun-type ret ptrs (count args) var)]
    (or (ffi/not-null (get-fun (intptr *unit*) name))
        (add-fun! (intptr *unit*) name type)))))

(defn fun-from-args [ptr ret args]
  (->> (fun-type ret
                 (util/ptrs-to-mem (map type-of args))
                 (count args)
                 false)
       (type)
       (ptr-of)
       (bitcast ptr)))

(defn call [fun args]
  (value
    (-call (intptr *builder*)
      (intptr fun)
      (util/ptrs-to-mem args)
      (count args)
      "")))

(defn new* [name args]
  (let [num    (count args)
        types  (mapv (fn [x] (type-of x)) args)
        values (mapv (fn [x] (intptr x)) args)
        ctor   (declare-fun! (str name "_new") (intptr ValueP) types)]
    (-> (intptr *builder*)
        (-call ctor (util/ptrs-to-mem values) num "")
        (value))))

(defn deref [val indices]
  (load (igep (intptr *builder*)
              (intptr val)
              (util/ptrs-to-mem indices)
              (count indices)
              "")
        ""))

(defn array-at [array idx]
  (load (gep (intptr *builder*)
             (intptr array)
             (util/ptrs-to-mem [idx])
             1
             "")
        ""))

(def box-type
  (type (anon-type (util/ptrs-to-mem [int8-ptr int8-ptr int64]) 3 false)))

(def box-ptr
  (ptr-of box-type))

(defn boxed? [a]
  (let [type (extern "torque_lang_Integer" TypeP)]
    (value
      (-icmp (intptr *builder*)
             eq
             (intptr (load type "")) 
             (intptr (value-type a))
             ""))))

(defn box [x]
  (when x
    (if (= (-> x type-of intptr kind) int-kind)
      (new* "torque_lang_Integer" [x])
      x)))

(defn unbox [x]
  (if (= (-> x type-of intptr kind) int-kind)
    x
    (let [box (bitcast x box-ptr)
          ptr (struct-gep (intptr *builder*) (intptr box) 2 "")]
      (value (-load (intptr *builder*) ptr "")))))

(defn allocate [t]
  (value (malloc (intptr *builder*) (intptr t) "")))

(defn return [value]
  (-return (intptr *builder*) (intptr (box value))))

(defn define-fun! [name ret args body-fn]
  (let [type  (fun-type ret (util/ptrs-to-mem args) (count args) false)
        fun   (add-fun! (intptr *unit*) name type)
        entry (value (add-block! fun "entry"))]
    (with-builder (builder entry)
      (return (body-fn fun)))
    fun))

(defn arg [fun n]
  (value (get-arg fun n)))

(defn fn-arg [fun n]
  (arg fun (inc n)))

(defn add [a b]
  ;; TODO: implement unboxing if types are known. if not,
  ;; check if we can do a dynamic dispatch
  (value (-add (intptr *builder*)
               (intptr (unbox a))
               (intptr (unbox b))
               "")))

(defn sub [a b]
  ;; TODO: implement unboxing if types are known. if not,
  ;; check if we can do a dynamic dispatch
  (value (-sub (intptr *builder*) (intptr a) (intptr b) "")))

(defn mul [a b]
  ;; TODO: implement unboxing if types are known. if not,
  ;; check if we can do a dynamic dispatch
  (value (-mul (intptr *builder*) (intptr a) (intptr b) "")))

(defn div [a b]
  ;; TODO: implement unboxing if types are known. if not,
  ;; check if we can do a dynamic dispatch
  (value (-div (intptr *builder*) (intptr a) (intptr b) "")))

(defn bit-and [a b]
  ;; TODO: implement unboxing if types are known. if not,
  ;; check if we can do a dynamic dispatch
  (value (-bit-and (intptr *builder*) (intptr a) (intptr b) "")))

(defn bit-or [a b]
  ;; TODO: implement unboxing if types are known. if not,
  ;; check if we can do a dynamic dispatch
  (value (-bit-or (intptr *builder*) (intptr a) (intptr b) "")))

(defn bsl [a b]
  ;; TODO: implement unboxing if types are known. if not,
  ;; check if we can do a dynamic dispatch
  (value (-shl (intptr *builder*) (intptr a) (intptr b) "")))

(defn bsr [a b]
  ;; TODO: implement unboxing if types are known. if not,
  ;; check if we can do a dynamic dispatch
  (value (-lshr (intptr *builder*) (intptr a) (intptr b) "")))

(defn cmp [op a b]
  (println op a b)
  ;; TODO: implement unboxing if types are known. if not,
  ;; check if we can do a dynamic dispatch
  (value (-icmp (intptr *builder*) op (intptr a) (intptr b) "")))

(defn ^:private not-nil? [x]
  (-icmp (intptr *builder*) ne (intptr nil*) (intptr x) ""))

(defn ^:private truthy [x]
  (if (= (kind (intptr (type-of x))) ptr-kind)
    (value (not-nil? x))
    x))

(defn ^:private branch [block cont branch-fn]
  (set-insert-block! (intptr *builder*) block)
  (when-let [x (box (branch-fn))]
    (br (intptr *builder*) cont)
    x))

(defn ^:private cont [type block values blocks]
  (set-insert-block! (intptr *builder*) block)
  (let [phi-value (phi (intptr *builder*) (intptr type) "")]
    (loop [blocks blocks
           values values]
      (let [block (first blocks)
            value (first values)]
        (when block
          (when value
            (add-incoming! phi-value
              (util/ptrs-to-mem [(intptr value)])
              (util/ptrs-to-mem [block])
              1))
          (recur (next blocks) (next values)))))
    (value phi-value)))

(defn if*
  ([test-fn then-fn else-fn]
   (if* ValueP test-fn then-fn else-fn))
  ([type test-fn then-fn else-fn]
   (let [fun        (current-fun)
         then-block (add-block! fun "then")
         else-block (add-block! fun "else")
         cont-block (add-block! fun "cont")
         test       (cond-br (intptr *builder*)
                             (intptr (truthy (test-fn)))
                             then-block
                             else-block)
         then-value (branch then-block cont-block then-fn)
         ;; then block might have changed, due to a nested if
         then-block (get-insert-block (intptr *builder*))
         else-value (branch else-block cont-block else-fn)
         ;; else block might have changed, due to a nested if
         else-block (get-insert-block (intptr *builder*))]
     (cont type cont-block
           [then-value else-value]
           [then-block else-block]))))

(defn recur* [point]
  (br (intptr *builder*) point)
  nil)

(defn short-and
  "Builds a short circuit logical and construct out of a list of
   builder functions"
  [& fs]
  (let [fun    (current-fun)
        out    (add-block! fun "")
        blocks (repeatedly
                 (count fs)
                 (fn [] (insert-block! out "")))
        values (mapv
                 (fn [f block]
                   (set-insert-block! (intptr *builder*) block)
                   (let [v (truthy (f))]
                     (cond-br (intptr *builder*) (intptr v) block out)))
                 fs blocks)]
    (cont int1 out values blocks)))

(defn ^:private value-identical [a b]
  (if*
    (fn []
      (short-and (partial boxed? a) (partial boxed? b)))
    (fn []
      (cmp eq (unbox a) (unbox b)))
    (fn []
      (cmp eq a b))))

(defn identical [a b]
  (if (= (type-of a) (type-of b))
    (let [k (kind (intptr (type-of a)))]
      (cond
        (== k int-kind) (cmp eq a b)
        (== k ptr-kind) (value-identical a b)
        :else (int int1 0)))
    (identical (box a) (box b))))

(defn global
  ([name init]
   (global name (type-of init) init))
  ([name type init]
   (let [g (add-global! (intptr *unit*) (intptr type) name)]
     (set-init! g (if init (intptr init) nil*))
     (value g))))

(defn find-global [name]
  (when-let [g (ffi/not-null (named-global (intptr *unit*) name))]
    (value g)))

(defn putc [ch]
  (call (declare-fun! "putchar" int32 [int32]) [(int int32 ch)]))

(defn log [s x]
  (let [s (global ".print" (value (const-string s 4 false)))]
    (call (declare-fun! "printf" int32 [int8-ptr] true) [s x])
    x))

(defn array [type vals]
  (let [ptrs (util/ptrs-to-mem vals)]
    (value (const-array (intptr type) ptrs (count vals)))))

(defn struct
  ([fields]
   (value (const-struct (util/ptrs-to-mem fields) (count fields) false)))
  ([t fields]
   (value (const-typed (intptr t) (util/ptrs-to-mem fields) (count fields)))))
