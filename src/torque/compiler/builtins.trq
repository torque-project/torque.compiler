;; -*- mode: clojure;-*-

(ns torque.compiler.builtins
 (:require
   [torque.compiler.emit :as emit]))

(def integer-type-name "torque_lang_Integer")
(def binary-type-name  "torque_lang_Binary")
(def array-type-name   "torque_lang_Array")
(def string-type-name  "torque_lang_string_String")
(def symbol-type-name  "torque_lang_symbol_Symbol")
(def keyword-type-name "torque_lang_keyword_Keyword")
(def vector-type-name  "torque_lang_vector_PersistentVector")
(def set-type-name     "torque_lang_set_PersistentHashSet")
(def map-type-name     "torque_lang_map_PersistentArrayMap")

(defn integer []
  (emit/import-type integer-type-name))

(defn binary []
  (emit/import-type binary-type-name))

(defn binary-type []
  (emit/find-type binary-type-name))

(defn array []
  (emit/import-type array-type-name))

(defn array-type []
  (emit/find-type array-type-name))

(defn ^:private binary-ctor []
  (emit/declare-ctor! binary-type-name [emit/int64 emit/int8-ptr]))

(defn vector []
  (emit/import-type vector-type-name))

(defn set []
  (emit/import-type set-type-name))

(defn make-binary
  ([size]
   (let [ctor      (binary-ctor)
         type-size (emit/sizeof (binary-type))
         ptr       (emit/allocate (emit/add type-size size))]
     (emit/call ctor [ptr size (emit/advance-ptr ptr type-size)]))))

(defn bget [b idx]
  (-> (emit/bitcast b (emit/ptr-of (binary-type)))
      (emit/get-field 2)
      (emit/buffer-at idx)))

(defn bset [b idx val]
  (let [byte (emit/trunc val emit/int8)]
    (-> (emit/bitcast b (emit/ptr-of (binary-type)))
        (emit/get-field 2)
        (emit/advance-ptr idx)
        (emit/store byte)))
  b)

(defn blength [b]
  (emit/get-field (emit/bitcast b (emit/ptr-of (binary-type))) 1))

(defn bdata [b]
  (emit/get-field (emit/bitcast b (emit/ptr-of (binary-type))) 1))

(defn mcopy [dst src len]
  (let [dst-ptr (emit/unbox dst)
        src-ptr (emit/unbox src)]
    (emit/memcpy dst-ptr src-ptr len)))

(defn ^:private array-ctor []
  (emit/declare-ctor! array-type-name [emit/int64 emit/ValueP]))

(defn make-array
  ([count]
   (let [ctor      (array-ctor)
         type-size (emit/sizeof (array-type))
         size      (emit/add type-size (emit/mul count emit/pointer-size))
         ptr       (emit/allocate (emit/add type-size size))
         array     (emit/bitcast
                     (emit/advance-ptr ptr size)
                     (emit/ptr-of emit/ValueP))]
     (emit/call ctor [ptr count array]))))

(defn aget [a idx]
  (-> (emit/bitcast a (emit/ptr-of (array-type)))
      (emit/get-field 2)
      (emit/buffer-at idx)))

(defn aset [a idx val]
  (-> (emit/bitcast a (emit/ptr-of (array-type)))
      (emit/get-field 2)
      (emit/advance-ptr idx)
      (emit/store val))
  a)

(defn alength [a]
  (emit/get-field (emit/bitcast a (emit/ptr-of (array-type))) 1))

(defn make-string
  ([s]
   (make-string
     (emit/global ".string.literal" (emit/string s))
     (emit/int (count s))))
  ([data size]
   (let [space  (emit/allocate (emit/sizeof (binary-type)))
         binary (emit/call (binary-ctor) [space size data])]
     (emit/new* string-type-name [binary (emit/box emit/one) (emit/box size)]))))

(defn make-symbol [sym]
  (let [ns   (some-> (namespace sym) (make-string))
        name (make-string (name sym))
        fqn  (make-string (str sym))]
    (emit/new* symbol-type-name [emit/nil* (or ns emit/nil*) name fqn])))

(defn make-keyword [sym]
  (let [ns  (some-> (namespace sym) (make-string))
        n   (make-string (name sym))
        fqn (make-string (str sym))]
    (emit/new* keyword-type-name [emit/nil* (or ns emit/nil*) n fqn])))

(defn integer? [x]
  (or (emit/int? x) (emit/instance-of (integer) x)))
